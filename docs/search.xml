<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo 构建静态文件无法生成 index.html 等文件]]></title>
      <url>%2F2017%2F05%2F13%2FHexoNPMERR%2F</url>
      <content type="text"><![CDATA[hexo g 无法生成 index构建情况如下图： 但是一些文件没有生成，如 index.html 文件。 查看 npm 安装各 hexo 插件的情况npm ls --depth 0 hexo 的一些插件未安装插件npm ERR! missing npm ERR! missing hexo-generator-archive… 解决逐一安装缺失的包 npm install hexo-generator-archive --save ... 安装完后重新构建即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写一（插件框架）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_1_Framework%2F</url>
      <content type="text"><![CDATA[唠叨本文唠叨了些CloudComapre这个开源软件的插件编写。 虽然这篇是入门教程，但是作为一只有梦想的程序猿，怎能像很多入门教程那样写个残缺的入门教程呢！ 所以这是一个完整插件的入门教程，我们要写的插件是qSAF(Scan Angle Filter)，这是可以过滤给定范围内点的扫描角度的插件。 下面分三篇来介绍，分别是插件框架篇、数据结构篇、算法实现篇。 这是第一篇，插件框架篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF CloudComapreCloudComapre是一个开源的3D点云和网格的处理软件，开可以处理各类点云格式的数据。 官网：http://www.cloudcompare.org/ Github：https://github.com/cloudcompare/cloudcompare CloudComapre插件编写使用qDummyPlugin插件模板创建自己的插件首先在Github上git下CloudComapre的源码， 再到 CloudComapre/plugins/qDummyPlugin 下 这个qDummyPlugin就是个插件的模板，用它来写自己的插件。 我们把这个模板插件文件夹拷贝一份，改为自己的插件名qSAF（当然，你也可以改为其他你喜欢的，以下不做累述） 现在qSAF里面有如下几个文件 我们需要做的是把里面的qDummyPlugin及类似的名字改为自己的qSAF。 注意：文件名和文件里面内容都要修改！ 如： 原本CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) #REPLACE ALL &apos;DUMMY&apos; OCCURENCES BY YOUR PLUGIN NAME #AND ADAPT THE CODE BELOW TO YOUR OWN NEEDS! option( INSTALL_QDUMMY_PLUGIN &quot;Check to install qDUMMY plugin&quot; OFF ) # CloudCompare &apos;DUMMY&apos; plugin if (INSTALL_QDUMMY_PLUGIN) project( QDUMMY_PLUGIN ) #load necessary libraries (see qPCV for an example) #add_subdirectory (LIB1) #if the plugin is an &apos;OpenGL filter&apos;, uncomment the line below #set( CC_OPENGL_FILTER ON BOOL) include( ../CMakePluginTpl.cmake ) #set dependencies to necessary libraries (see qPCV for an example) #target_link_libraries( ${PROJECT_NAME} LIB1 ) #include_directories( ${LIB1_INCLUDE_DIR} ) endif() 修改后的CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) option( INSTALL_QSAF_PLUGIN &quot;Check to install qSAF plugin&quot; OFF ) if (INSTALL_QSAF_PLUGIN) #CloudCompare ‘SAF’ plugin project( QSAF_PLUGIN ) include( ../CMakePluginTpl.cmake ) endif() 剩下的qSAF.h、qSAF.cpp和qSAF.qrc就不一一列出了 修改后变成这样： 使用qmake构建pro文件在终端进入到你的插件的qSAF目录，执行： qmake -project -r CMakeLists.txt 就会在qSAF目录下构建一个项目的pro文件。 导入工程到QT现在把CloudComapre导入到QT， 在CloudComapre-plugins-plugins.pro中，加上自己的插件： 保存刷新后就会在项目上看到了。 pro文件编写由于qmake自动生成的pro文件不适合我们要写的插件，所以要自己修改pro文件。 pro文件的编写可以参考： QT的pro文件编写 里面的常规pro文件就是qSAF的。 里面的路径可以不用修改，具体看你项目的Release生成的位置， 特别注意：指定生成路径中的libs和plugins要正确 完成模板插件框架没错！这就完成了，你的插件已经做出来了！现在可以Run一下或者Debug一下看看啦~ 选中点云，使用qSAF，会这样： 莫慌！这是正常现象，因为你的qSAF具体实现还没有写呢！ 遇到问题1. 编译出错可能原因： qSAF.h、qSAF.cpp和qSAF.qrc这三个文件里面的qDummyPlugin及类似的名字要改为自己的qSAF，如果改错或没改，可能报错。 自己写的代码有错，这个视情况而定 2. 运行的CloudComapre插件上没有你编写的插件的快捷方式可能原因 插件的生成路径出错了，自己插件的pro文件中的plugins指定生成路径要正确。 个性化插件现在来个性化一下我们的插件 在qSAF.h中： // 设置插件的唯一ID Q_PLUGIN_METADATA(IID &quot;cccorp.cloudcompare.plugin.qSAF&quot;) // 设置插件名字 virtual QString getName() const override { return &quot;SAF&quot;; } // 设置插件的描述 virtual QString getDescription() const override { return &quot;Filter the scanning angle in a range of points&quot;; } // 设置插件图标，这个要在 qSAF.cpp 里设置图标路径 virtual QIcon getIcon() const override; // 设置插件要执行的操作（重点） void doAction(); 插件doAction()我们编写插件是要做些事情，在CloudComapre插件中就是在doAction()中实现按下插件SAF后要做的事。 这个函数在qSAF.cpp中，你会发现复制的模板插件的doAction()是这样的（把qDummyPlugin改为qSAF啦）： void qSAF::doAction() { //m_app should have already been initialized by CC when plugin is loaded! //(--&gt; pure internal check) assert(m_app); if (!m_app) return; /*** HERE STARTS THE ACTION ***/ //put your code here //--&gt; you may want to start by asking parameters (with a custom dialog, etc.) //This is how you can output messages m_app-&gt;dispToConsole(&quot;[qSAF] Hello world!&quot;,ccMainAppInterface::STD_CONSOLE_MESSAGE); //a standard message is displayed in the console m_app-&gt;dispToConsole(&quot;[qSAF] Warning: qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::WRN_CONSOLE_MESSAGE); //a warning message is displayed in the console m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); //an error message is displayed in the console AND an error box will pop-up! /*** HERE ENDS THE ACTION ***/ } 我们要做的就是在 /*** HERE STARTS THE ACTION ***/ 下面写自己的插件代码。 刚才你看的错误信息就是这句： m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 这是控制台输出的错误信息。 错误信息(ERR_CONSOLE_MESSAGE)同时在控制台和窗体形式出现，而其他标准信息(STD_CONSOLE_MESSAGE)、警告信息(WRN_CONSOLE_MESSAGE)，则只在控制台显示。 现在删掉/*** HERE STARTS THE ACTION ***/下面的，改为自己的一句： m_app-&gt;dispToConsole(&quot;[qSAF] 程序是从错误开始的！&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 结果如下： 插件框架完成现在已经完成了插件框架的编写啦。 其实只要使用CloudComapre提供的插件模板qDummyPlugin，改成自己的就可以啦。 现在可以发挥你的想象力，在doAction()里面随心所欲地做各种事情啦。 但是只有框架还不够，要想对点云进行操作，和SAF功能的具体实现，还需要了解CloudComapre中点云的数据结构： CloudComapre插件编写二（数据结构） 如果你对点云数据结构虐它如虐狗，可以戳这里： CloudComapre插件编写三（算法实现）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写二（数据结构）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_2_DataStructure%2F</url>
      <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第二篇，数据结构篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF 前文概要在上回中，我们已经实现了插件的框架，现在要在doAction()中写插件的具体实现。 插件需求我们要做的是一个qSAF(Scan Angle Filter)插件，它可以过滤给定范围内点的扫描角度。 也就是用户输入两个角度值，如20度、70度， 过滤输出每个点的扫描角度在大于等于20度、小于等于70度的范围的点云。 需求分析要实现这个功能，我们需要有一个界面，可以让用户输入两个角度，然后获取两个角度值，接着遍历每个点，获取每个点的扫描角度，然后获得角度在大于等于20度、小于等于70度范围的点云，显示输出。 简单地说，就是要： 输入界面 遍历角度 输出点云 1. 输入界面是QT基础；3. 输出点云是CC套路；只有2. 遍历角度有点纠结。 因此本文第二篇主要介绍2. 遍历角度，即介绍点云中点的数据结构。 注意：不同类型文件的数据结构不同，本文以激光雷达文件(.las)来做介绍。 las文件的读入首先，我们从宇宙的起源开始说起…… 额，还是从.las文件的读入开始说起吧~ .las文件的读入首先进过FileIOFilter这个类，判断是雷达文件(.las)后，进入LASFilter类，并从它的loadFile()函数读入。 先看下loadFile()函数声明： virtual CC_FILE_ERROR loadFile(QString filename, ccHObject&amp; container, LoadParameters&amp; parameters) override; 特别注意三个传入参数！我就是忽视了这里才找了好久。。。 QString filename 是点云文件名（包括路径） ccHObject&amp; container 是一个实体（ccHObject），可以添加点云（ccPointCloud） LoadParameters&amp; parameters 是选择读入文件后提示要勾选雷达的哪些信息 然后看下loadFile()函数体 .las文件首先从io流读入，再使用liblas这个外部库存储： liblas::Reader reader(liblas::ReaderFactory().CreateWithStream(ifs)); 这里说下liblas： liblas是用于读取和编写非常常见的LAS LiDAR格式的C/C++库，我们使用它来做对LAS的直接读取。 官网如下： https://www.liblas.org/ 然后把liblas读入的文件进行各种处理和封装，最终封装成ccPointCloud ccPointCloud* loadedCloud = 0; int sfIndex = loadedCloud-&gt;addScalarField(field-&gt;sf); ... loadedCloud-&gt;setName(chunkName); ... loadedCloud-&gt;setMetaData(LAS_SCALE_X_META_DATA, QVariant(lasScale.x)); ... loadedCloud-&gt;addPoint(P); ... 然后通过： container.addChild(loadedCloud); 添加到ccHObject中 所以：点云的信息，都是存储在ccPointCloud中的！ 而扫描角度存储在ccPointCloud的标量域中(ccScalarField) ccPointCloud前面已经说了很多ccPointCloud了，它就是CloudCompare中存储点云的类。 我们看看它的说明 //! A 3D cloud and its associated features (color, normals, scalar fields, etc.) /** A point cloud can have multiple features: - colors (RGB) - normals (compressed) - scalar fields - an octree strucutre - per-point visibility information (to hide/display subsets of points) - other children objects (meshes, calibrated pictures, etc.) **/ 我要的扫描角度就在scalar fields 然而在ccPointCloud没有直接的方法获得众多标量域中的扫描角度 终于在它的父类ChunkedPointCloud中发现了 ChunkedPointCloudccPointCloud的父类ChunkedPointCloud中有如下两个函数： # 通过标量域名字获得其在标量域数组中的索引 int ChunkedPointCloud::getScalarFieldIndexByName(const char* name) const # 通过索引获得特定标量域的指针 ScalarField* ChunkedPointCloud::getScalarField(int index) const 通过这两个函数就可以获得指向扫描角度的指针了，要想访问扫描角度中每个点的值，需要使用ScalarField父类GenericChunkedArray的方法 GenericChunkedArray# 通过每个点的索引访问特定标量域的每个的的值 inline const ElementType* getValue(unsigned index) const LASOpenDlg标量域中扫描角度的名字可以在LASOpenDlg.h中找到 &quot;Scan Angle Rank&quot; 整理下思路 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 这样就获取到了每个点的扫描角度值，然后： 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 上面整理的思路在下篇实现，现在我们已经知道怎么获取点云中扫描角度的值了，那其他信息呢？ 点云其他信息的获取看下在QT的调试信息： 我们可以发现，其实点云的信息都能在ccPointCloud中获取，比如点容量、点数量、点坐标、标量域、颜色值等。 其中，标量域vector中有9项信息，存储的标量域顺序为： [0] Point Source ID [1] Scan Angle Rank [2] Flightline Edge [3] Scan Direction [4] Number of Returns [5] Return Number [6] Time [7] Intensity [8] Classification 至于如何获取每种数据，都有相应的方法实现，不是在ccPointCloud，就是在它的父类中，耐心点总能找到的~ 下篇概要下篇是算法实现篇，主要说了qSAF插件的具体实现，包括上面说的： 输入界面 遍历角度 输出点云 请戳这里： CloudComapre插件编写三（算法实现）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写三（算法实现）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_3_Algorithm%2F</url>
      <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第三篇，算法实现篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF 前文概要在上回中，我们知道了点云中扫描角度的存储结构，下面我们来讲qSAF的具体实现。 UI界面新建QT设计器界面类，命名为ccSAFDlg，在ccSAFDlg.ui文件设计简单的界面。 因为我们只需要一个范围，一个确认取消键，所以我把它弄成这样子： doubleSpinBox要设置范围：0.00到90.00，默认值分别设为20.00和70.00。 ccSAFDlg.h： #ifndef CCSAFDLG_H #define CCSAFDLG_H #include &quot;ui_SAFDlg.h&quot; #include &lt;QDialog&gt; namespace Ui { class ccSAFDlg; } class ccSAFDlg : public QDialog, public Ui::ccSAFDlg { Q_OBJECT public: explicit ccSAFDlg(QWidget *parent = 0); protected slots: //! Saves (temporarily) the dialog paramters on acceptation void saveSettings(); }; #endif // CCSAFDLG_H ccSAFDlg.cpp： #include &quot;ccSAFDlg.h&quot; //定义两个静态阈值，并初始化 static double threshold_1 = 20; static double threshold_2 = 70; ccSAFDlg::ccSAFDlg(QWidget *parent) : QDialog(parent), Ui::ccSAFDlg() { setupUi(this); //关联信号槽 connect(buttonBox, SIGNAL(accepted()), this, SLOT(saveSettings())); //初始化设置阈值 doubleSpinBox_1-&gt;setValue(threshold_1); doubleSpinBox_2-&gt;setValue(threshold_2); } void ccSAFDlg::saveSettings() { //OK后重新赋值 threshold_1 = doubleSpinBox_1-&gt;value(); threshold_2 = doubleSpinBox_2-&gt;value(); } 现在界面就做好了。 插件doAction实现至于doAction的实现，点云其中的数据结构，可以参考第二篇，数据结构篇 简单地说，我们需要： 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 大体的算法思路上是没有问题的，但是有个纠结的地方，就是是否使用进度条。 实测SAF处理一个雷达文件， 使用进度条耗时：129.1s 不用进度条耗时：3.5s 这种压倒性的差距让我果断砍掉真·进度条，没错！我使用假·进度条，就是不会动的进度条。 这样短时间的处理使用假·进度条，既不会降低处理速度，也不会降低用户体验~ 下面就是完整代码，注释中有真·进度条的实现（[进度条]），但不推荐使用 void qSAF::doAction() { //当插件加载时，m_app应该已经被CC初始化了 assert(m_app); if (!m_app) return; //获取选择的实体 const ccHObject::Container&amp; selectedEntities = m_app-&gt;getSelectedEntities(); //获取选择的实体数量 size_t selNum = selectedEntities.size(); //确保只选择一个实体 if (selNum != 1) { m_app-&gt;dispToConsole(&quot;[SAF] Select only one cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } ccHObject* ent = selectedEntities[0]; assert(ent); //确保选择的实体是POINT_CLOUD类型 if (!ent || !ent-&gt;isA(CC_TYPES::POINT_CLOUD)) { m_app-&gt;dispToConsole(&quot;[SAF] Select a real point cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //从选择的实体中转换成ccPointCloud*类型 ccPointCloud* pc = static_cast&lt;ccPointCloud*&gt;(ent); //获取点云的数量m_count unsigned count = pc-&gt;size(); //初始化阈值变量 static double threshold_1 = 20; static double threshold_2 = 70; double threshold_temp = 0; //显示插件ui窗体 { ccSAFDlg safDlg(m_app-&gt;getMainWindow()); safDlg.doubleSpinBox_1-&gt;setValue(threshold_1); safDlg.doubleSpinBox_2-&gt;setValue(threshold_2); if(!safDlg.exec()) { return; } //存储阈值 threshold_1 = safDlg.doubleSpinBox_1-&gt;value(); threshold_2 = safDlg.doubleSpinBox_2-&gt;value(); } //显示进度条窗体 QProgressDialog pDlg; pDlg.setWindowTitle(&quot;SAF&quot;); pDlg.setLabelText(QString(&quot;Scan Angle Filter\nfrom %1 to %2&quot;).arg(threshold_1).arg(threshold_2)); //[进度条]设置进度条总范围 //pDlg.setRange(0, count); pDlg.setCancelButton(0); pDlg.show(); QApplication::processEvents(); QElapsedTimer timer; //计时开始 timer.start(); ScalarType scanAngle; CCLib::ReferenceCloud rangeAnglerc(pc); //确保 threshold_1 小于 threshold_2 if(threshold_1 &gt; threshold_2) { threshold_temp = threshold_1; threshold_1 = threshold_2; threshold_2 = threshold_temp; } //[进度条]进度条的取消SAF按钮 //bool wasCancelled = false; //获取 Scan Angle Rank 的索引 int scanAngleSFIndex = pc-&gt;getScalarFieldIndexByName(&quot;Scan Angle Rank&quot;); //[重点]遍历每个点的操作 for(unsigned i = 0; i &lt; count; ++i) { //获取每个点的扫描角度 scanAngle = pc-&gt;getScalarField(scanAngleSFIndex)-&gt;getValue(i); //取扫描角度的绝对值 if(scanAngle &lt; 0) { scanAngle = -scanAngle; } //如果扫描角度在给定的阈值范围，则添加它的索引到参考云 if(threshold_1 &lt;= scanAngle &amp;&amp; scanAngle &lt;= threshold_2) { rangeAnglerc.addPointIndex(i); } // //[进度条]重置进度条 // pDlg.setValue(i); // QCoreApplication::processEvents(); // //[进度条]取消SAF处理 // if (pDlg.wasCanceled()) // { // wasCancelled = true; // break; // } } //把 ReferenceCloud 类型克隆成 ccPointCloud 类型 ccPointCloud* rangeAnglepc = pc-&gt;partialClone(&amp;rangeAnglerc); //判断rangeAnglepc是否为空，即所选范围内是否有点 if(!rangeAnglepc) { m_app-&gt;dispToConsole(&quot;[SAF] Failed to extract the range angle subset.&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //计算SAF后点数所占的百分比和SAF过程所花的时间 m_app-&gt;dispToConsole(QString(&quot;[SAF] %1% of scan angle points are filtered&quot;).arg((rangeAnglerc.size() * 100.0) / count, 0, &apos;f&apos;, 2), ccMainAppInterface::STD_CONSOLE_MESSAGE); m_app-&gt;dispToConsole(QString(&quot;[SAF] Timing: %1 s.&quot;).arg(timer.elapsed() / 1000.0, 0, &apos;f&apos;, 1), ccMainAppInterface::STD_CONSOLE_MESSAGE); //关闭进度条 pDlg.close(); QApplication::processEvents(); // //[进度条]取消SAF // if (wasCancelled) // { // m_app-&gt;dispToConsole(&quot;[SAF] SAF was cancelled&quot;, ccMainAppInterface::STD_CONSOLE_MESSAGE); // return; // } //隐藏原始点云 pc-&gt;setEnabled(false); //添加新的一组DB实体 ccHObject* cloudContainer = new ccHObject(pc-&gt;getName() + QString(&quot;_saf&quot;)); //设置新点云并添加到实体 rangeAnglepc-&gt;setVisible(true); rangeAnglepc-&gt;setName(&quot;SAF Point Cloud&quot;); cloudContainer-&gt;addChild(rangeAnglepc); //添加实体到DB树 m_app-&gt;addToDB(cloudContainer); //刷新 m_app-&gt;refreshAll(); } 效果 结语经过了三篇的学习，终于实现了个完整的插件。 回顾我们学习的路线：插件框架 -&gt; 数据结构 -&gt; 算法实现 我们不仅从中学会了CC插件的编写，也学到了QT的pro文件编写、QT界面设计、CC运作流程、点云数据结构等。 而我在学习这个插件编写的过程收获更多，因为我是看代码两个月，写代码两小时，Debug两天（差不多啦~不要纠结为什么222~） 看代码的过程是非常痛苦的，CC里面大量的模板编程思想，接口设计思想，还有去他继承谁爸爸的爸爸…… 但是期间确实学到很多，以此作为分享，望共勉！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT的pro文件编写]]></title>
      <url>%2F2017%2F04%2F26%2FQTProFile%2F</url>
      <content type="text"><![CDATA[常规pro文件下面是CloudCompare中一个自己写的插件的pro文件， pro文件编写可按照如下方式写。 # 添加QT的模块 QT += widgets \ opengl # 指明让qmake生成哪种makefile文件，app表示应用程序，lib表示库 TEMPLATE = lib # 指明生成的库的名字 TARGET = qSAF # 指明编译依赖路径 DEPENDPATH += .\ # 包含头文件路径 INCLUDEPATH += .\ $$PWD/../ # 工程的头文件路径 HEADERS += qSAF.h \ ../ccStdPluginInterface.h \ ../ccPluginInterface.h \ ../ccMainAppInterface.h \ ccSAFDlg.h # 工程的源文件路径 SOURCES += qSAF.cpp ../ccStdPluginInterface.cpp \ ccSAFDlg.cpp # 工程的资源文件路径 RESOURCES += qSAF.qrc #CC (CloudCompare核心算法库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB # 包含CC的头文件路径 INCLUDEPATH += $$PWD/../../CC/include # 包含CC的依赖路径 DEPENDPATH += $$PWD/../../CC #qCC_db (CloudCompare数据库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB INCLUDEPATH += $$PWD/../../libs/qCC_db DEPENDPATH += $$PWD/../../libs/qCC_db # 工程的ui文件路径 FORMS += \ SAFDlg.ui # Mac系统下，则执行括号内的代码 macx { # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../../Release/libs -Wl #指定生成路径 DESTDIR = $$PWD/../../../Release/CloudCompare.app/Contents/plugins } # Mac外的其他Unix系统下(Linux)，则执行括号内的代码 unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic #指定生成路径 DESTDIR = $$PWD/../../../Release/plugins } # Windows系统下，则执行括号内的代码 win32 { # windows only }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ IO 库条件状态及EOF]]></title>
      <url>%2F2017%2F04%2F15%2FCppConditionStateAndEOF%2F</url>
      <content type="text"><![CDATA[文本文件判空问题对于空文本文件的判断问题引起了我对 IO 库中条件状态和 EOF 的探究。 就是这段程序： int vehicle_number; fstream infile; infile.open(&quot;vehicle.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; vehicle_number; ...... } infile.close(); } 它可以打开空文本文件并运行到 while(!infile.eof()) 循环里面。由于是空文本文件，它进入里面会造成一些问题，所以需要对文件进行判空。 EOFEOF（End Of File） 常用于： 文件结束标志 函数出错的返回值 在 C++ IO 库中可用作： 条件状态的判定 现在让我们看看 IO 库中的描述。 IO 库条件状态【表一】IO 库条件状态 状态 含义 strm::iostate strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能 strm::badbit strm::badbit用来指出流已崩溃 strm::failbit strm::failbit用来指出一个IO操作失败了 strm::eofbit strm::eofbit用来指出流达到了文件结束 strm::goodbit strm::goodbit用来指出流未处于错误状态。此值保证为零 s.eof() 流 s 的 eofbit 置位，则返回 true s.fail() 流 s 的 failbit 或 badbit 置位，则返回 true s.bad() 流 s 的 badbit 置位，则返回 true s.good() 若流 s 处于有效状态，则返回 true s.clear() 将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void s.clear(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是strm::iostate。返回 void s.setstate(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void s.rdstate() 返回流 s 的当前条件，返回值类型为 strm::iostate 【表二】四种条件状态 状态 含义 数值 good() eof() bad() fail() rdstate() ios::goodbit 流状态完全正常 0 1 0 0 0 goodbit ios::eofbit 已达到文件结束 2 0 1 0 0 eofbit ios::badbit 输入（输出）流出现非致命错误，可挽回 1 0 0 1 0 badbit ios::failbit 输入（输出）流出现致命错误，不可挽回 4 0 0 0 1 failbit 我们先看【表一】的关于 EOF 的这两行： 状态 解释 strm::eofbit strm::eofbit用来指出流达到了文件结束 s.eof() 流 s 的 eofbit 置位，则返回 true 这里指出当流读到文件结束时，eofbit 置 1 ，用于标识读取到文件的末尾。 而 eof() 是当 eofbit 置位（置 1）时才返回，并不是读到文件末尾就返回。 所以使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 文本文件判空问题的解释现在就可以解释最初的问题了，让我们回过头看看。 当程序第一次运行到 while(!infile.eof()) 时，infile.eof() 读到文件末尾的 EOF，但并不是立刻返回 true，只是 eofbit 置位，所以 infile.eof() 还是 false 的状态，所以会进入 while 循环。 文本文件判空问题的解决 把流对象状态当做条件使用 if(infile.is_open()) { while(infile &gt;&gt; vehicle_number) { ...... } } 使用 peek() istream::peek() 用于读取并返回流的下一个字符（返回值为 char 类型），但并不读取该字符到输入流中，即流指针依然指向原来位置，并不后移。 if(infile.is_open()) { while(infile.peek() != EOF) { infile &gt;&gt; vehicle_number; ...... } } 重复读入非空文本文件最后一个字符问题经过上面的解释，我们已经知道了文本文件如何判空。但由于 EOF 的锅，若用 while(!infile.eof()) 还会导致重复读入非空文本文件最后一个字符的问题。 看下面这段代码： char c; fstream infile; infile.open(&quot;test.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; c; cout &lt;&lt; c; } } infile.close(); 和文本文件判空问题的代码相似，只是读入字符存储到 char 类型变量中，并把其输出。 然后我们在 test.txt 中保存 abc 这三个字符。 运行的结果是： abcc 即 while(!infile.eof()) 重复执行了最后一趟，多输入了字符 c 。 这个问题和文本文件判空问题的解决办法一样，都是使用 peek() 或者把流对象当做 while 的条件来解决。 总结 使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 只有一个流处于无错状态时，我们才可以对它读写数据。因此代码通常应该在使用一个流之前检查它是否处于良好状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos 7 挂载 NTFS 分区]]></title>
      <url>%2F2017%2F03%2F29%2FCentos7NTFS%2F</url>
      <content type="text"><![CDATA[NTFS-3G安装使用 NTFS-3G 实现，可以挂载 NTFS，还可以挂载 HFS+ 等，以下是在 Centos 7 下安装 NTFS-3G 及挂载 NTFS 分区 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo sudo yum update sudo yum install ntfs-3g 查看分区fdisk -l 挂载# d、e、f改成你想要挂的盘符名字 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f # d、e、f改成你想要挂的盘符名字，sdb3这些改为要挂的分区 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d mount -t ntfs-3g /dev/sdb4 /mnt/windows/e mount -t ntfs-3g /dev/sdb5 /mnt/windows/f 卸载umount /mnt 设置开机自动挂载sudo vim /etc/fstab #只读式挂载： /dev/sda1 /mnt/windows/c ntfs-3g ro,umask=0222,defaults 0 0 #读写式挂载： /dev/sda1 /mnt/windows/c ntfs-3g rw,umask=0000,defaults 0 0 #或者： /dev/sda1 /mnt/windows/c ntfs-3g defaults 0 0 设置后开机无法启动（无法挂载）网上很多教程都是如上几步就好了~ 然而我的无法开机。 如下图： 这样应该需要输入root密码，用root账户登录修复模式， 然后 vim /etc/fstab 删除刚刚添加的东西， reboot 就能进入系统了 所以之前之前忙活的都没用了？ 后来试了下原来 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d 这句本身就无法挂载！ 然后可以通过 sudo mount -o ro /dev/sdb3 /mnt/windows/d 挂载，但是只能通过终端访问，就是下面这个👇 其他问题无法挂载的解决办法实现了只能在终端访问 #创建挂载点 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f #挂载分区 sudo mount -o ro /dev/sdb3 /mnt/windows/d sudo mount -o ro /dev/sdb4 /mnt/windows/e sudo mount -o ro /dev/sdb5 /mnt/windows/f #添加上面挂载分区到这里面 sudo vim /etc/rc.d/rc.local #更改权限 chmod +x /etc/rc.d/rc.local Thankshttp://www.cnblogs.com/gbyukg/archive/2011/11/02/2232343.html http://www.jianshu.com/p/f578b575fcaa http://askubuntu.com/questions/462381/cant-mount-ntfs-drive-the-disk-contains-an-unclean-file-system https://www.techbrown.com/mount-ntfs-file-system-centos-7-rhel-7.shtml]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下QT编译输出路径错误：ld unknown option ...]]></title>
      <url>%2F2017%2F03%2F26%2FMacQTCompilerOutputPathError%2F</url>
      <content type="text"><![CDATA[ERROR: ld unknown option rpathMac指定qmake的生成路径时，用 -Wl,-rpath,$$PWD/.. 而不是 -Wl,-rpath=$$PWD/.. 如下： macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../Release/libs -Wl # 指定生成路径 DESTDIR = $$PWD/../../Release } Linux则用 -Wl,-rpath=$$PWD/.. unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic # 指定生成路径 DESTDIR = $$PWD/../../Release/libs } ERROR: ld unknown option BsymbolicMac 不支持-Bsymbolic，所以不能这样： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl,-Bsymbolic 应该删去-Bsymbolic，如下： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos 7 设置开机自动联网]]></title>
      <url>%2F2017%2F03%2F25%2FCentos7Networking%2F</url>
      <content type="text"><![CDATA[ls /etc/sysconfig/network-scripts/ # 找到ifcfg-e`npxxx`，如我的是`rk-scripts` sudo vim /etc/sysconfig/network-scripts/ifcfg-enp4s0 # 一般文件里面有下面这些 TYPE=Ethernet BOOTPROTO=dhcp DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=enp4s0 UUID=4d0c8a3a-50bf-497a-9b04-f5fba085ef08 DEVICE=enp4s0 ONBOOT=no # 把`ONBOOT=no`该为` ONBOOT=yes`，保存即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shadowsocks-Qt5 For Centos 7]]></title>
      <url>%2F2017%2F03%2F25%2FShadowsocks-Qt5ForCentos7%2F</url>
      <content type="text"><![CDATA[InstallIf you use the traditional yum package management tool, you need to download the appropriate version of the repo file from the Copr to /etc/yum.repos.d/, and then install through yum. As follows: # Centos 7 wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo sudo mv librehat-shadowsocks-epel-7.repo /etc/yum.repos.d/ sudo yum update sudo yum install -y shadowsocks-qt5 Config Explanation of the fields: Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux ProxyGo to Settings-Network-Network proxy, turn on proxy. Use the sock proxy local_address: the address your local listens (default:1080) local_port: local portocal (default:127.0.0.1) Have fun!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare功能概要]]></title>
      <url>%2F2017%2F03%2F21%2FCloudCompareFunction%2F</url>
      <content type="text"><![CDATA[File open：打开 save：保存 Global Shift settings：设置最大绝对坐标，最大实体对角线 Primitive Factory：对点云进行原始加工，改变原始点云的形状 3D mouse：对3D鼠标（如3Dconnexion）的支持 Close all：关闭所有打开的实体 Quit：退出 Edit： Clone：克隆选中的点云 Merge：合并两个或者多个实体。可以合并点云（原始云会被删除）；可以合并网格（原始网不会修改，CC会创建一个新的网格结构） Subsample：采集原始点云的子样本，可以用随机、立体、基于八叉树的方式采集，子样本会保持原始点云的标量、颜色、法线等性质。 Apply Transformation：可以对选中的实体做变换（4*4矩阵、轴线角，欧拉角） Multiply / Scale：让选中实体的坐标倍增。 Translate / Rotate (Interactive Transformation Tool)：可以相对于另外一个实体或者坐标系移动选中的实体 Segment (Interactive Segmentation Tool)：通过画2D多边形分隔选中的实体 Crop：分割一个或多个在3D-Box里面的点云。 Edit global shift and scale：进行全局变换和和比例缩放。 Toggle (recursive)：用于控制键盘的快捷键。 Delete：删除选中的实体。 Colors &gt; Set Unique：为所选实体设置唯一一个的颜色 Colors &gt; Colorize：为所选实体着色，具体表现为分别用所选颜色乘以当前颜色的RGB而得到新的颜色 Colors &gt; Levels：通过调整颜色的柱形图变色，类似于Photoshop的Levels方法 Colors &gt; Height Ramp：为所选实体设置颜色渐变（线形、梯形、环形） Colors &gt; Convert to Scalar Field：将当前的 RGB 颜色字段转换为一个或几个标量字段 Colors &gt; Interpolate from another entity：在所选实体中插入另外一个实体的颜色 Colors &gt; Clear：移除所选实体的颜色域 Normals &gt; Compute：计算所选实体的法线 Normals &gt; Invert：反转所选实体的法线 Normals &gt; Orient Normals &gt; With Minimum Spanning Tree：用同样的方法重新定位点云的全部法线（最小生成树） Normals &gt; Orient Normals &gt; With Fast Marching：用同样的方法重新定位点云的全部法线（快速行进法） Normals &gt; Convert to &gt; HSV：将云的法线转换到 HSV 颜色字段 Normals &gt; Convert to &gt; Dip and Dip direction SFs：转换点云的法线到两个标量域 Normals &gt; Clear：为选定的实体移除法线 Octree &gt; Compute：强制计算给定实体的八叉树 Octree &gt; Resample：通过代替每个八叉树单元内的所有点来重新取样 Mesh &gt; Delaunay 2.5D (XY plane)：计算点云在xy平面上的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Delaunay 2.5D (best fit plane)：计算点云在最佳平面的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Convert texture/material to RGB：将选定网格的网格材料和纹理信息转换为逐个点的 RGB 字段 Mesh &gt; Sample points：在一个网格中随机取样 Mesh &gt; Smooth (Laplacian)：平滑一个网格（Laplacian smoothing，拉普拉斯平滑算法） Mesh &gt; Subdivide：细分网格，此算法递归细分网格三角形，直到他们的表面细分到用户指定值之下。 Mesh &gt; Measure surface：测量网格的总体表面积和每个三角形的平均表面积，在控制台输出 Mesh &gt; Measure volume：测量闭合网格的体积，在控制台输出 Mesh &gt; Flag vertices：检查网格的基本特性，为每个网格样本做标志：0 = normal，1 = border，2 = non-manifold Mesh &gt; Scalar field &gt; Smooth：平滑网格顶点相关联的标量场。此方法与高斯滤波（Gaussian Filter）相反。运用qPCV插件后，此方法特别有用 Mesh &gt; Scalar field &gt; Enhance：增强与网格顶点相关联的标量场。运用qPCV插件后，此方法特别有用 Sensors &gt; Edit：修改指定传感器内外在参数 Sensors &gt; Ground Based Lidar &gt; Create：创建’Ground Based Lidar’ (= TLS)传感器实体，附加到所选的点云 Sensors &gt; Ground Based Lidar &gt; Show Depth Buffer：显示选中的Ground Based Lidar的深度 Sensors &gt; Ground Based Lidar &gt; Export Depth Buffer：以ASCII文件的形式导出选中的Ground Based Lidar传感器的深度图 Sensors &gt; Camera Sensor &gt; Create：创建影像传感器 Sensors &gt; Camera Sensor &gt; Project uncertainty：输出影像模块不确定的点云，输出不确定的x、y、z、3D信息 Sensors &gt; Camera Sensor &gt; Compute points visibility (with octree)：统计选中影像传感器选中的点云。0=NOT VISIBLE，1=VISIBLE Sensors &gt; View from sensor：更改当前的 3D 视图影像设置以匹配选定的传感器的设置 （用泡沫视图模式） Sensors &gt; Compute ranges：计算全部点（对于任何点云）相对于指定传感器的范围 Sensors &gt; Compute scattering angles：计算全部点（对于任何有法线的云）相对于选中传感器分散的角度 Scalar fields &gt; Show histogram：对当前选中的实体显示有效标量域的柱形图 Scalar fields &gt; Compute statistical parameters：计算统计分布（高斯分布、威布尔分布） Scalar fields &gt; Gradient：计算标量域的梯度 Scalar fields &gt; Gaussian filter：通过应用一个立体高斯滤镜，平滑一个标量域 Scalar fields &gt; Bilateral filter：用双边滤镜平滑一个标量域 Scalar fields &gt; Filter by Value：用标量值筛选选定的云 Scalar fields &gt; Convert to RGB：将有效的标量场转化为RGB颜色域 Scalar fields &gt; Convert to random RGB：将有效的标量场转化为随机的RGB颜色域 Scalar fields &gt; Rename：对选中实体重命名有效的标量域 Scalar fields &gt; Add constant SF：用一个常数添加一个标量域 Scalar fields &gt; Add point indexes as SF：用点索引的方式为所选点云创建一个新的标量域 Scalar fields &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Scalar fields &gt; Set SF as coordinate(s)：为选中的点云设置标量域的坐标 Scalar fields &gt; Arithmetic：可以对在同一个点云的两个标量域进行标准运算（+，-，*，/），或者对单个标量域进行函数运算 Scalar fields &gt; Color Scales Manager：色阶管理，可以管理和创建新色域 Scalar fields &gt; Delete：对选中的实体删除有效的标量域 Scalar fields &gt; Delete all (!)：对选中的实体删除全部的有效标量域 Tools： Level：可以选择三个点确定一个平面来操作 Point picking：可以选择一个、两个、三个点来得到各种信息，如点的坐标、RGB、标量值、距离、角度等信息（尤其是两点间的距离） Point list picking：可以选择多个点创建一个点列表，可以输出为一个文件、一个新点云、一个折线 Clean &gt; Noise filter：类似于qPCL插件的S.O.R.滤镜，但又更多功能 Projection &gt; Unroll：展开圆柱或圆锥体的点云成一个平面 Projection &gt; Rasterize：栅格化点云（转化为2.5D网格），然后可以导出为一个新点云或者一个光栅图像 Projection &gt; Contour plot to mesh：可以把一组折线转化为网格，输出边缘轮廓线 Projection &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Registration &gt; Match bounding-box centers：调整所有选中的实体，让它们的中心在一个地方 Registration &gt; Match scales：匹配所有选中实体的规模 Registration &gt; Align (point pairs picking)：在两个实体中挑选至少三个对应的点来对齐两个实体 Registration &gt; Fine registration (ICP)：自动精确地融合两个实体。前提是：①两个云大体上相融；②表现为同样的对象或者至少有同样的形状 Distances &gt; Cloud/Cloud dist. (cloud-to-cloud distance)：计算两个点云之间的距离 Distances &gt; Cloud/Mesh dist. (cloud-to-mesh distance)：计算点云和网格之间的距离 Distances &gt; Closest Point Set：计算两个点云之间最近的点的集合 Statistics &gt; Local Statistical Test：可以以标量域的局部统计为基础进行分割和过滤点云 Statistics &gt; Compute Stat. Params：计算统计分布（高斯分布、威布尔分布） Segmentation &gt; Label Connected Components：设置最小距离，把所选的云分割成更小的部分，每一部分相互连接 Segmentation &gt; Cross Section：用户可以定义一个裁剪框，可调整框的范围和方向，来裁剪点云。可以用来：①在一个或多个维度重复分割过程；②获取多边形的轮廓 Segmentation &gt; Extract Sections：可以在一个点云的顶部画或者导入多边形来提取截面和轮廓 Fit &gt; Plane：匹配点云中的一个平面和输出各种信息，如拟合 RMS、 垂直平面、地质的倾角、倾角方向值等 Fit &gt; Sphere：适配点云中的一个球体 Fit &gt; 2D Polygon：适配点云中的二维多边形 Fit &gt; Quadric：适配点云中的2.5D曲面 Other &gt; Density：估量一个点云的密度 Other &gt; Curvature：估量一个点云的曲率 Other &gt; Roughness：估量一个点云的粗糙程度 Other &gt; Remove duplicate points：通过设置两点之间最小距离来删除重复的点 Display： Full screen：全屏 Refresh：刷新，强制刷新有效的3D视图的内容（OpenGL图形重绘） Toggle Centered Perspective：在正交视图和对象中心视图模式中切换 Toggle Viewer Based Perspective：在正交视图和透视图中切换 Lock rotation about vert. axis：锁定围绕Z轴的影像旋转 Enter bubble-view mode：进入泡沫视图模式 Render to File：可以渲染当前的3D视图成一个图像文件（支持多数标准文件格式），还可以缩放以适应更大分辨率的屏幕 Display settings：对各种显示进行设置：颜色和材质、色阶、标签、其他 Camera settings：影像设置 Save viewport as object：保存当前3D视图的可视体的参数（影像位置和方、透视状态）为一个可视实体，这个实体自动地添加DB树的根 Adjust zoom：调整缩放比例 Test Frame Rate：测试帧速率，让有效的3D视图在一个较短时间旋转从而估量平均帧数，结果在控制台显示 Lights &gt; Toggle Sun Light：切换太阳光 Lights &gt; Toggle Custom Light：切换自定义的光 Shaders and Filters &gt; Remove filter：禁用任何活动的着色器或者OpenGL过滤器 Active scalar field &gt; Toggle color scale：为所选活动的实体切换色阶 Active scalar field &gt; Show previous SF：改变当前所选对象的标量域，激活先前的标量域 Active scalar field &gt; Show next SF：改变当前所选对象的标量域，激活下一个的标量域 Console：控制台（显示/隐藏） Toolbars：工具栏，包括主工具栏、标量域、视图、插件、GL滤镜 Reset all GUI elements：退出钱自动存储当前GUI信息（位置和工具栏的可见性等），可以恢复原始配置 Plugins：Standard plugins： qHPR (Hidden Point Removal)：如果点云是闭合曲面，则可以过滤（删除）掉通过当前3D影像不能看到的云 qPCL (Point Cloud Library Wrapper)：有PCL库一些方法的接口，主要包括：①计算法线和曲率②异常点和噪声点的去除③平滑点云（移动最小二乘法） qPCV (ShadeVis / Ambient Occlusion)：计算点云的明亮度，类似于光线来自于对象周围的半球或球体（可以自定义光线距离） qPoissonRecon (Poisson Surface Reconstruction)：Poisson表面重建，用三角网络生成算法构建的简单的表面 qRansacSD (RANSAC Shape Detection)：随机抽样一致形状检测，运用自动形状检测算法的简单接口 qSRA (Surface of Revolution Analysis)：计算一个点云和一个假定旋转平面之间的距离（旋转平面用2D轮廓定义），距离计算好后，用户可以创建一个偏差的2D图或者圆柱或圆锥的投影 qCANUPO (Point Cloud Classification)：可自动对点云进行分类，也可以手动分类 qM3C2 (Robust C2C Distances Computation)：用独特的方法计算两个点云之间的有向（稳健）距离 qCork (Boolean Operations on Meshes)：可以执行网格中的布尔操作（也称CSG = 构造实体几何），它基于Cork库 qAnimation：动画渲染插件 qFacets：可以从点云中自动提取二维切面，以它们的垂直距离分开 qCSF (Cloth Simulation Filter)：基于布模拟滤波算法，能实现地面点与非地面点的分离，去除非地面点 qCompass：简单地实现点云中地质结构的它的轨迹的数字化 qBroom (qVirtualBroom)：高效地扫描和清理 qHoughNormals：计算法法线 qGMMREG：对小型实体的非刚性云的匹配 qLAS_FWF：这个插件可以读写标准雷达文件，可以在命令模式下打开LAS 1.3+文件 qPoissonRecon：可以让输入的点云颜色映射到成网格（快速直接地分配到颜色接近输入点颜色的网格顶点） OpenGL ‘shaders’ plugins： qEDL (Eye Dome Lighting)：实时底纹滤镜，用来在空白的点云或者网格中增强少量特质（除了几何信息外，它不依赖于其他信息） qSSAO (Screen Space Ambient Occlusion)：实时底纹滤镜，与环境相似的遮挡 qBlur：一个简单的模糊处理滤镜，主要用于开发人员的演示 Deprecated qKinect (Point Cloud Acquisition with a Kinect)：可以用Kinect设备获取（有色的）点云 3D Views： New：创建3D视图 Close：关闭3D视图 Close All：关闭所有3D视图 Tile：共享的所有 3D 视图之间的显示空间 Cascade：用串联的方式重新排列所有 3D 视图 Next：激活顺序创建的下一个3D视图 Previous：激活顺序创建的上一个3D视图 Help： Help：帮助文档 About：CloudCompare版本信息 About Plugins：插件信息 Thanks： CloudCompare Documentation CloudCompare Wiki Wikipedia]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux Notes]]></title>
      <url>%2F2017%2F03%2F15%2FLinuxNotes%2F</url>
      <content type="text"><![CDATA[删除文件 rm xxx(文件名) 删除文件夹（-r：向下递归；-f：强制删除） rm -rf xxx(文件夹路径) 从网上下载文件 wget http;//…… .tar.gz 登录服务器 ssh [-p port] username@servername 上传本地文件到服务器 scp [-P port] /path/filename username@servername:/path 上传目录到服务器 scp [-P port] -r local_dir username@servername:remote_dir 从服务器上下载文件 scp [-P port] username@servername:/path/filename /var/www/local_dir 从服务器下载整个目录 scp [-P port] -r username@servername:/var/www/remote_dir /var/www/local_dir]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Makefile 问题及解决]]></title>
      <url>%2F2017%2F03%2F13%2FMakefileIssue%2F</url>
      <content type="text"><![CDATA[问题一makefile文件的clean出错 解决clean下面的那句命令没有缩进，应该用[Tab]缩进 小结 利用 Google、stackoverflow 等含金量高的问题解决平台 注意语法规范 问题二 解决newhello:hello.o hello_fn.o 中的newhello应该写成hello，应该与hello.c中的名字一样 小结 注意编译运行的文件名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[并行笔记]]></title>
      <url>%2F2017%2F03%2F13%2FParallelComputingNotes%2F</url>
      <content type="text"><![CDATA[并行计算（Parallel Computing）并行计算（平行计算）是相对于串行计算来说的。 它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。 所谓并行计算可分为时间上的并行（流水线技术）和空间上的并行（多个处理器并发的执行计算）。 基本思想是用多个处理器来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。 用于多核处理器 缓存算法 并行算法（parallel algorithms）概念 串行算法（serial algorithms）一般只有一种模型，即为随机存取机器模型（random access machine model） 并行算法及并行空间，有许多其他模型。如：动态多线程模型（dynamic multithreading），适用于多核机器中，为内存共享的编程而设计，不适用于分布式编程 衍生（spawn）：衍生的代码可以跟着父程序同时执行 同步（sync）：等待所有子程序完成，才执行这条指令 调度:把动态的、不断延伸的程序，映射到可用的处理器上 多线程计算，并行指令流，它其实是个有向无环图（DAG） 并行时间设：Tp：任意程序运算在p个处理器上的运行时间 T1；功（work），串行运行时间 T∞：关键路径长度，DAG中最长路径 Tp ≥ T1/p Tp ≥ T∞ T1/Tp = Θ(p) —— 线性加速 T1/Tp ＞ Θ(p) —— 超级线性加速 （对于这个模型不可能，其他有可能通过类似缓存的机制实现） P^ = T1/Tp —— 并行度，是能达到的最大速度，用功除以最短路径长度，是关键路径上可以并行完成的平均分量的功 调度算法目的调度的目的是：将计分配到p个处理器上，通常在实时操作系统上 贪心调度在每一步做地尽可能多 第一种：完整步骤：p个线程则用p个处理器 第二种：不完整步骤：多于p个线程运行p个线程；少于p个线程就全部线程运行 一个贪婪算法执行任意计算G，若功为T1，关键路径为T∞，p个处理器 Tp ≤ T1/p + T∞ T1/p：完整步骤 T∞：不完整步骤 贪心算法是线性加速度：P^ = T1/T∞ CilkCilk —— 英特尔Cilk语言，多用于并行编程的语言 cilk int fib(int n) { if (n &lt; 2) { return n; } else { int x, y; x = spawn fib(n - 1); y = spawn fib(n - 2); sync; return x + y; } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端]]></title>
      <url>%2F2017%2F03%2F11%2FFancyMacTerminal%2F</url>
      <content type="text"><![CDATA[唠叨一下自从装了黑苹果后一直用着 Mac 自带的终端（Terminal），相比 Windows 的终端根本无法同台竞技！毕竟 Mac 是基于 Unix 嘛~ 对开发友好太多了。 就是下面这个家伙了👇 本来没觉得什么，直到我看到它👇 颜值碾压，有木有！ 所以就着手折腾了…… iTerm2iTerm是一个非常好的终端模拟器，官网地址：http://iterm2.com/，需要下载它。 zshzsh 是一款强大的虚拟终端，是 Oh My Zsh 的爸爸，所以需要先装它。 在命令行输入： zsh --version 如果输入zsh的当前版本号就说明装好了，一般Mac自带有的 如果没装则需要输入： brew install zsh zsh-completions 这是用Homebrew装，需要Mac上有Homebrew，它的网站：https://brew.sh/ Oh My ZshOh My Zsh 是基于 zsh 的一个扩展工具集，它提供了丰富的扩展功能 它可以通过curl或者wget来安装 via curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 装好之后就可以换到 agnoster 主题，就是之前看到的那张颜值主题，Oh My Zsh 一般自带有这个主题。 可以看看它的默认主题： ls ~/.oh-my-zsh/themes 需要修改主题只需： vim ~/.zshrc 然后把里面 ZSH_THEME 的值改为 ZSH_THEME=&quot;agnoster&quot;，保存退出 （点击这里还有各种主题，任君翻牌~） 应用配置： chsh -s /bin/zsh 重启 iTerm2 然后你会惊喜地发现…… 和颜值主题并不一样！ 难道官方坑爹？ 震惊！oh-my-zsh 竟然做出这种事！ 嘛~ 原来少了 Powerline 的字符集 PowerlineGit 下来安装： git clone git@github.com:powerline/fonts.git cd fonts ./install.sh 然后到 iterm2 配置，设置字体为Roboto Mono for Powerline： 这样就可以有颜值图的效果了~ 然而终端下的 vim 编辑器还是一种颜色~ 作为一个追求完美的 geek 怎能容许此等瑕疵呢！ 所以就继续捣鼓 solarized 配色。 solarizedSolarized 是个很牛逼的配色项目，主流OS、IDE、Editor都有它影子。 # git下Solarized 的源码 git clone git://github.com/altercation/solarized.git # 进入文件夹 cd solarized/vim-colors-solarized/colors #下面可能要管理员权限 sudo mkdir -p ~/.vim/colors sudo cp solarized.vim ~/.vim/colors/ # 创建.vimrc文件 sudo vim ~/.vimrc # 把下面这三行复制进去 syntax enable set background=dark colorscheme solarized 然后保存 .vimrc, 退出 之后打开用 vim 打开文件就是这种效果了： Thanks iTerm2 robbyrussell/oh-my-zsh powerline/fonts altercation/solarized]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 简易入门教程]]></title>
      <url>%2F2017%2F01%2F25%2FMarkdownTutorial%2F</url>
      <content type="text"><![CDATA[自己整理的 Markdown 简介、编辑器推荐、语法、特征等，是 Markdown 的简易入门教程 目录 概述 简介 官方文档 Markdown编辑器 初级语法 标题 粗体和斜体 段落和换行 分隔线 引言 列表 无序列表 有序列表 代码 行内代码块 段落代码块 链接 网址链接 图片链接 指定图片宽高 用图床获取外链 进阶语法 标签 目录 表格 脚注 公式 流程图 序列图 其他 兼容HTML 特殊字符自动转换 反斜杠 自动链接 感谢 概述 简介 Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等。 官方文档 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown编辑器 在线编辑器 dillinger——漂亮强大，支持md, html, pdf 文件导出。 简书——非常漂亮的博客平台，可以自动备份，直接拖入图片。 Windows MarkdownPad——一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 MarkPad——开源软件，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。 Cmd Markdown——作业部落出品，全平台并支持Web端 Mac Mou——简洁优雅，免费又好用，中文兼容性好。 Typora——极致简洁，自定义皮肤。 MacDown——简洁优雅，开源免费。 Ulysses——文字写作推荐。 多平台 Atom——github出的编辑器，支持各种编程语言，可装Markdown插件。 sublimetext——专业编辑器，支持各种编程语言。 初级语法 标题 Markdown 支持两种标题的语法，类 Atx 和类 Setext 形式。 Atx（注意#后面有个空格） # 一级标题 ## 二级标题 ### 三级标题 Setext（-与=数目任意，最好三个及以上，比较直观） 一级标题 ====== 二级标题 ------ 粗体和斜体 粗体 **这是粗体** __这是粗体__ 斜体 *这是斜体* _这是斜体_ 段落和换行 第一种写法（上图的这是第一段），直接敲两个回车键即可 这是第一段 这是第二段 第二种写法（上图的这是第二段），在写完一段后敲两个空格，然后回车写下一段 这是第二段 这是第三段 第三种写法（上图的这是第三段），在写完一段后用HTML的语法：&lt;br /&gt;作为换行，然后写下一段 这是第三段&lt;br /&gt;这是第四段 这是第三段&lt;br /&gt; 这是第四段 分隔线 可以在一行中用三个及以上的星号、减号、等于号、底线来建立分隔线，行内不能有除空格外的其他东西，注意莫被打脸。 (≖ ‿ ≖)✧ *** --- === ___ 引言 &gt; 我想只用一个 “&gt;” 号来写一个多行的引用，所以在扯鸡巴蛋地码字占空间，好像差不多了吧，嗯嗯~ --- &gt; 还有一种写法就是每一行都用一个 “&gt;” 号 &gt; 这样写比较美观一点 --- &gt; &gt; 另外一种就是嵌套引用，就像我一样，用两个“&gt;” 列表 无序列表 无序列表可以在每行开头用星号、加号、减号来表示，也可以三者混合一起，推荐使用相同的字符，避免混乱。 * 一朵百合花 * 两朵百合花 * 三朵百合花 有序列表 有序列表用数字接着一个英文句点来表示，数字可无序，但还是推荐使用1.、2.，避免混乱。 1. 一朵百合花 2. 两朵百合花 3. 三朵百合花 代码 行内代码块 I am a `code` I am a `` ` `` 段落代码块 #### 第一种 int main() { printf(&quot;我是个段落代码块&quot;); return 0; } 另外，可以用三个反引号和语言名，作为标记代码所使用的语言 我的 Mou 编辑器不能识别 (ノ▼Д▼)ノ 链接 网址链接 网址链接有两种形式：行内式、参考式。 不管是哪一种，链接文字都是用 [方括号] 来标记，双引号&quot;&quot;的title可写可不写。 行内式 [huihut](https://huihut.github.io/) [huihut](https://huihut.github.io/ &quot;huihut&quot;) [huihut](https://huihut.github.io/ &apos;huihut&apos;) 参考式 一般写法 [huihut][1] [1]: https://huihut.github.io/ 隐式链接标记——可省略id，只需要[text]与下面[方括号]内容相同即可 [Google][] [Google]: http://google.com/ 拓展 这里的链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [text][a] [text][A] 链接 title 可以用双引号、单引号、圆括号包起来，因此，下面这三种链接的定义都是相同： [1]: https://huihut.github.io/ &quot;title&quot; [1]: https://huihut.github.io/ &apos;title&apos; [1]: https://huihut.github.io/ (title) 特别注意：Markdown.pl 1.0.1 会忽略单引号包起来的链接 title 图片链接 图片链接与上面的网址链接类似，同样有两种形式：行内式和参考式，只不过图片链接在前面加上一个感叹号!，在此不做累述。 行内式 ![huihut](http://ojlsgreog.bkt.clouddn.com/H_ya.png) 参考式 ![谷歌][1] [1]: https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png &quot;Google&quot; 指定图片宽高 Markdown 一般不支持指定图片的宽高，若要指定宽高可以使用普通的 &lt;img&gt; 标签 &lt;img src=&quot;./xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; 如果需要居中可以在外围包围div标签 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; &lt;/div&gt; 使用支持指定图片大小的 Markdown 编辑器，如 Mou ![](xxx.png =100x100) 用图床获取外链 网上有许多图床，这里推荐两个 七牛图床 和 极简图床。 七牛图床 极简图床 进阶语法 标签 方法一 title: Markdown 简易入门教程 date: 2017-01-25 1:45:50 tags: Markdown categories: 技术 方法三 tags: - Markdown - 语言 categories: - 技术 方法三 tags: [Markdown,语言] categories: [技术] 目录 方法一 这种目录其实是用 HTML 加 Markdown的链接 实现，分为两个部分，目录部分和标题部分。 目录部分——实质是链接，链接的[地址]填需要跳转到的标题的id属性（自定义）。 [跳到标题一](#title1) 标题部分——实质是HTML的标题标签，标签里面的id属性等于待跳转的目录的[地址]。 &lt;h1 id=&quot;title1&quot;&gt;标题一&lt;/h1&gt; 方法二 这种方法非常简单，就是直接添加 [TOC]，标题1~6样式的内容会被提取出来作为目录，然而有些编辑器不能使用这功能，如 Mou 不能使用。我是在有道云笔记的 Markdown 中截图的。 [TOC] # 标题一 …… ## 标题二 …… ### 标题三 这里有个jQuery插件，貌似可以让Markdown生成目录： https://github.com/i5ting/i5ting_ztree_toc 表格 表格一般这样子写，这应该是最简单的写法了 id | name | score --- | --- | --- 001 | Mark | 90 002 | Ford | 80 003 | Alan | 95 还有就是对齐了，用:对齐，:写在在---的左边就是左对齐，右边就是右对齐，两边都写就是居中。 |long_long_id|long_long_name|long_long_score| | --- | :---: | ---: | | 001 | Mark | 90 | | 002 | Ford | 80 | | 003 | Alan | 95 | 脚注 这是脚注一[^1] [^1]: 脚注一 公式 方法一：使用Google Chart &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法二：使用forkosh &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法三：使用codecogs &lt;a href=&quot;https://www.codecogs.com/eqnedit.php?latex=x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/gif.latex?x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; title=&quot;x=\frac{-b\pm \sqrt{b^{2}-4ac}}{2a}&quot; /&gt;&lt;/a&gt; 方法四：使用MathJax引擎——先加载脚本&lt;script&gt;，后解析公式。 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 流程图 像流程图这种复杂的功能不推荐在 Markdown 中使用，因为很多编辑器都不支持，我使用了几个编辑器都不能生成流程图，所以上图是在为知笔记官方 Markdown 新手指南中找到的。 123456789st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 更多关于流程图的语法说明： https://github.com/adrai/flowchart.js 序列图 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 更多关于时序图的语法说明： https://github.com/bramp/js-sequence-diagrams 其他语法 兼容HTML Markdown 可以和 HTML 混编，甚至可以完全用 HTML 语法来写。要注意在 HTML 标签中的 Markdown 代码是不起作用的。 &lt;font color=&apos;blue&apos; style=&apos;font-size:30px&apos;&gt;蓝色&lt;/font&gt; &lt;div&gt; # HTML 标签里面的 Markdown 语法不起作用 **你看我没有变粗** &lt;/div&gt; 特殊字符自动转换 HTML 语法——在 HTML 中所有&lt;和&amp;都要转换，包括链接（URL） 用 &amp;lt; 表示 &lt;——起始标签 用 &amp;amp; 表示 &amp; ——标记 HTML 实体 Markdown 语法——Markdown 则会自动转换 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号。如： *literal asterisks* 可用 \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 自动链接 网址自动链接 &lt;https://huihut.github.io/&gt; 电子邮件自动链接 &lt;huihut@outlook.com&gt; 感谢 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown——入门指南 Markdown语法手册 好用的Markdown编辑器一览 markdown中插入图片怎么定义图片的大小或比例？ Markdown进阶语法整理 为知笔记 Markdown 新手指南 Markdown中插入数学公式的方法 i5ting/i5ting_ztree_toc flowchart.js adrai/flowchart.js js-sequence-diagrams bramp/js-sequence-diagrams]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git Notes]]></title>
      <url>%2F2017%2F01%2F24%2FGitNotes%2F</url>
      <content type="text"><![CDATA[安装 Windows ① 安装 Git for Windows https://git-for-windows.github.io/ ② 使用git客户端 https://git-scm.com/download/win Mac ① 用图形界面git安装工具安装 http://sourceforge.net/projects/git-osx-installer/ ② 用homebrew安装 brew install git Fedora sudo yum install git-all Debian &amp; Ubuntu sudo apt-get install git-all 源码编译安装 ① 安装依赖工具 Fedora sudo yum install dh-autoreconf curl-devel expat-devel gettext-devel \ openssl-devel perl-devel zlib-devel Debian &amp; Ubuntu apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \ libz-dev libssl-dev ② 下载git源码 http://git-scm.com/download ③ 编译安装 tar -zxf git-1.7.2.2.tar.gz cd git-1.7.2.2 make prefix=/usr/local all sudo make prefix=/usr/local install 配置 设置本地git用户名和邮箱 #用户名 git config --global user.name &quot;huihut&quot; #邮箱 git config --global user.email &quot;huihut@outlook.com&quot; #检查配置是否正确 git config --list 生成SSH key ssh-keygen -t rsa -C &quot;huihut@outlook.com&quot; 需要确认一些信息，一般默认就行。 获取ssh key #首先转换到git的默认的路径下，再cat cat ~/.ssh/id_rsa.pub #输出如下 ssh-rsa AAAA....huihut@outlook.com 复制ssh-rsa…com到Github SSH keys上,如下图： 下载到本地仓库 用克隆命令（SSH or HTTPS） git clone git@github.com:huihut/huihut.github.io.git 一般推荐使用SSH，因为HTTPS一般来说fetch和push代码都需要输入账号和密码，比较麻烦，而且速度较慢；但是在某些只开放HTTP端口的公司内部就无法使用SSH协议而只能用HTTPS。 上传到远程仓库 新建远程仓库，如：huihut.github.io 终端进入本地仓库文件夹，如： cd /Users/xx/code/Github/huihut.github.io 初始化仓库 git init 将本地的仓库和远程的仓库进行关联（SSH key ） git remote add origin git@github.com:huihut/huihut.github.io.git 新建文件或者修改文件 touch test.txt 添加新建或修改的文件到仓库 #添加特定文件 git add test.txt #添加此目录下全部文件 git add . 将文件提交到仓库 git commit -m &quot;add test.txt&quot; 将本地仓库的内容推送到远程仓库 git push -u origin master 注意：第一次push的时候最好加上-u参数，这样git就会把本地master分支与远程的master分支关联起来，我们以后的push操作就不再需要加上-u参数了。 分支新建分支git branch huihut 转换分支git checkout huihut 新建并转换分支git checkout -b huihut 分支合并# 把master分支合并到huihut分支 git merge master huihut 查看分支git branch 删除分支git branch -d huihut 查询 查看工作区和版本库里面最新版本的区别 git diff HEAD -- readme.txt 查询状态 git status 修改 丢弃工作区的修改 git checkout -- readme.txt 清理仓库 find . -name &quot;.git&quot; | xargs rm -Rf 删除文件 rm test.txt 删除文件夹（-r：向下递归；-f：强制删除） rm -rf /Users/xx/test 大文件存储Github 上传单个文件应该低于100M。上传文件超过50M会给予警告，超过100M则会不允许上传，这时可以使用git lfs上传。 git-lfs 官网 安装 Git-LFSgit lfs install 跟踪大文件 跟踪某类型文件 git lfs track &quot;*.psd&quot; 跟踪多个文件 git lfs track &quot;aa.psd&quot; &quot;bb.pdf&quot; &quot;cc.zip&quot; 确保gitattributes被跟踪git add .gitattributes # 可以在.gitattributes查看跟踪的文件 cat .gitattributes 接下来步骤和平常一样git add . git commit -m &quot;Add Large File&quot; git push origin master 常见错误： error: failed to push some refs to .... 问题的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。① 方法一：强推（-f），视情况加-u git push -f -u origin master ②方法二：先把git的东西fetch到你本地然后merge后再push git fetch git merge 这两句等价于 git pull 可是，这时候又出现了如下的问题： 上面出现的 [branch “master”]是需要明确(.git/config)如下的内容 [branch &quot;master&quot;] remote = origin merge = refs/heads/master 这等于告诉git2件事: 1，当你处于master branch, 默认的remote就是origin。 2，当你在master branch上使用git pull时，没有指定remote和branch，那么git就会采用默认的remote（也就是origin）来merge在master branch上所有的改变 如果不想或者不会编辑config文件的话，可以在bush上输入如下命令行： git config branch.master.remote origin git config branch.master.merge refs/heads/master 之后再重新git pull下 git pull 最后git push你的代码（视情况加-u ） git push -u origin master Thanks 廖雪峰的官方网站 . Git教程 YotrolZ的博客 . 本地Git仓库和远程仓库的创建及关联 ConquerMobileApp博客 . git push用法和常见问题分析 pringbarley博客 . git常用命令 git-lfs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Notes]]></title>
      <url>%2F2017%2F01%2F22%2FPythonNotes%2F</url>
      <content type="text"><![CDATA[Python 中文编码在Python文件中如果未指定编码格式，则默认ASCII编码。此时如果输出中文字符，则会报错（SyntaxError）。 解决方法为在文件开头加入以下内容： ① 写法一： # coding = utf-8 ② 写法二： # -*- coding: UTF-8 -*- Python 指定解释器路径 若使用python xx.py运行Python程序，可以不写解释器路径； 若使用./xx.py运行Python程序，则要写解释器路径 ① 写法一： #!/usr/bin/env python 推荐使用写法一。用写法一可以在你安装多版本Python时，取PATH中第一个Python执行；若配置了虚拟环境，也可以保证你用虚拟环境中的Python执行 ② 写法二： #!/usr/bin/python 默认的Python解释器的路径 Python 变量类型Python 列表List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。 列表用[ ]标识。是python最通用的复合数据类型。看这段代码就明白。 列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认0开始的，从右到左索引默认-1开始，下标可以为空表示取到头或尾。 加号（+）是列表连接运算符，星号（*）是重复操作。如下实例： # coding = utf-8 list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ] tinylist = [123, &apos;john&apos;] print list # 输出完整列表 print list[0] # 输出列表的第一个元素 print list[1:3] # 输出第二个至第三个的元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素 print tinylist * 2 # 输出列表两次 print list + tinylist # 打印组合的列表 以上实例输出结果： [&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2] runoob [786, 2.23] [2.23, &apos;john&apos;, 70.2] [123, &apos;john&apos;, 123, &apos;john&apos;] [&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;] Python元组元组是另一个数据类型，类似于List（列表）。 元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 # coding = utf-8 tuple = ( &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ) tinytuple = (123, &apos;john&apos;) print tuple # 输出完整元组 print tuple[0] # 输出元组的第一个元素 print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素 print tinytuple * 2 # 输出元组两次 print tuple + tinytuple # 打印组合的元组 以上实例输出结果： (&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2) runoob (786, 2.23) (2.23, &apos;john&apos;, 70.2) (123, &apos;john&apos;, 123, &apos;john&apos;) (&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;) 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的： # coding = utf-8 tuple = ( &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ) list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ] tuple[2] = 1000 # 元组中是非法应用 list[2] = 1000 # 列表中是合法应用 Python 元字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 # coding = utf-8 dict = {} dict[&apos;one&apos;] = &quot;This is one&quot; dict[2] = &quot;This is two&quot; tinydict = {&apos;name&apos;: &apos;john&apos;,&apos;code&apos;:6734, &apos;dept&apos;: &apos;sales&apos;} print dict[&apos;one&apos;] # 输出键为&apos;one&apos; 的值 print dict[2] # 输出键为 2 的值 print tinydict # 输出完整的字典 print tinydict.keys() # 输出所有键 print tinydict.values() # 输出所有值 输出结果为： This is one This is two {&apos;dept&apos;: &apos;sales&apos;, &apos;code&apos;: 6734, &apos;name&apos;: &apos;john&apos;} [&apos;dept&apos;, &apos;code&apos;, &apos;name&apos;] [&apos;sales&apos;, 6734, &apos;john&apos;] Python 运算符Python算术运算符以下假设变量a为2，变量b为3： 运算符 描述 实例 ** 幂 - 返回x的y次幂 a**b 为2的3次方，输出结果 8 // 取整除 - 返回商的整数部分 a//b 输出结果 0 , b//a 输出结果 1 注意：Python中没有++和--的自增/减运算符拓展：为什么Python、Ruby中没有自增/减运算符？ 在Python中有a += 1，没有a++。 a += 1改变了变量，表达式新建了个对象，把a+1的结果存在这个对象中，然后将引用a指向该对象，使得变量a改变。 a++改变了对象本身（直接对对象进行++），这个对象指的是内存中存放基本类型的数据的地址所指的内容。 在 Python 中，数值对象是一种不可变类型。在创建对象之后，其值就不能再被改变。 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != Python赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &lt;&lt; &gt;&gt; 左移，右移运算符 &amp; 位 ‘AND’ ^ &#124; 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 Thanks [Python语法] http://www.runoob.com/python/python-tutorial.html[Python教程] http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000[Python中为什么没有++和–（自增/减）] http://blog.csdn.net/guang09080908/article/details/47273765[为什么 Python、Ruby 等语言弃用了自增运算符？] https://www.zhihu.com/question/20913064]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyCharm自动安装pymysql包失败]]></title>
      <url>%2F2017%2F01%2F21%2FPyCharmInstallPymysqlFail%2F</url>
      <content type="text"><![CDATA[问题描述：在PyCharm中新建Web2Py项目后提示没有pymysql，自动安装失败，如图： 解决方案：1. 安装pip在终端输入 pip -V 如果显示版本路径，就说明pip已经安装了如果没有安装pip则需要在终端安装 ①使用脚本安装pip： 各平台（管理员运行）： python get-pip.py ②使用包管理器安装pip： Mac： sudo easy_install pip Debian &amp; Ubuntu: sudo apt-get install python-pip Fedora: sudo yum install python-pip 2. 安装pymysqlpip install pymysql 3. 正常情况下以上两步就行了。然而我的项目中依然提示没有pymysql，结果发现只是Python版本选错了(ノ▼Д▼)ノ我pymysql是安装到Python2.7，而PyCharm项目是用Python2.6所以就到Preferences &gt; Project Interpreter中调成Python2.7就行了， Thanks http://stackoverflow.com/questions/36956124/permision-issues-while-using-and-installing-python-packages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搬瓦工Shadowsocks安装及配置多用户(服务端)]]></title>
      <url>%2F2016%2F12%2F03%2FBandwagonShadowsocksServer%2F</url>
      <content type="text"><![CDATA[安装Shadowsocks服务方案一： 搬瓦工VPS为我们准备了Shadowsocks的一键安装，直接在控制面板中有，非常方便。 只需在左边最下面选择Shadowsocks Server 然后选择Install Shadowsocks Server 等待安装完成后选择Go Back 现在可以看到加密协议默认aes-256-cfb,端口默认443 ,密码随机 如果是自己用，到这里就可以使用了，直接在客户端填好这些配置信息就好了。 方案二： 如果不在控制面板上安装或者是在其他没有一键安装的VPS上，可以使用命令安装。 Debian/Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks 优化Shadowsocks性能 在终端通过ssh连上vps（Windows可以用putty连，Mac直接在终端就可以了） 在终端输入vi /etc/sysctl.d/local.conf创建配置文件 按i插入 插入以下内容 # max open files fs.file-max = 1024000 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for high-latency network net.ipv4.tcp_congestion_control = hybla # forward ivp4 net.ipv4.ip_forward = 1 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 配置生效：sysctl --system 配置多用户如果想多用户使用的话就需要更改配置。 首先通过ssh连上vps 在终端输入vi /etc/shadowsocks.json创建配置文件 按i插入 插入以下内容（用户数任意，注意最后一个用户密码后面没有逗号） { &quot;server&quot;:&quot;my_server_ip&quot;, #填入你的IP地址 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: { &quot;8381&quot;: &quot;foobar1&quot;, #端口号，密码 &quot;8382&quot;: &quot;foobar2&quot;, &quot;8383&quot;: &quot;foobar3&quot;, &quot;8384&quot;: &quot;foobar4&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } Explanation of the fields(配置说明): Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 现在就可以启动了，有两种方式启动，前端和后端。前端启动：ssserver -c /etc/shadowsocks.json；后端启动：ssserver -c /etc/shadowsocks.json -d start；停止：ssserver -c /etc/shadowsocks.json -d stop；重启(修改配置要重启才生效)：ssserver -c /etc/shadowsocks.json -d restart 设置开机启动在终端输入vi /etc/rc.local，把里面最后的带有ssserver的一大段默认的代码删除掉，再把ssserver -c /etc/shadowsocks.json -d start加进去，按wq保存退出。 到此就配置好了，试试多用户运行吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ Notes]]></title>
      <url>%2F2016%2F11%2F20%2FCppNotes%2F</url>
      <content type="text"><![CDATA[常成员函数声明：&lt;类型标志符&gt;函数名（参数表）const； class A { private: const int a; //常对象成员 public: int getValue() const; //常成员函数 int getValue(); //普通成员函数 }; int main() { const A a(); //常对象 canst A *p = &amp;a; //常指针 canst A &amp;q = a; //常引用 } 说明： 常对象只能调用常成员函数，不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数。 普通对象可以调用全部成员函数。 const关键字可以用于对重载函数的区分。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用this指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 在C++中，this指针被隐含地声明为: X const this,这意味着 *不能给this 指针赋值。 由于this并不是一个常规变量，所以，不能取得this的地址。 函数函数默认值赋值前面定义的变量之前必须要先赋值后面定义的变量 void fun(int a, int b, int c); //没有赋值 void fun(int a, int b, int c = 30); //可以 void fun(int a, int b = 20, int c = 30); //可以 void fun(int a = 10, int b = 20, int c = 30); //可以 void fun(int a = 10, int b, int c); //不可以 void fun(int a = 10, int b, int c = 30); //不可以 一般函数声明赋默认值，函数定义不赋值 void fun(int a = 10, int b = 20, int c = 30); //声明 void fun(int a, int b, int c) { std::cout &lt;&lt; a+b+c &lt;&lt; std::endl; } 函数实现时赋值，只覆盖前面的值 void fun(int a = 10, int b = 20, int c = 30); //声明 int main() { fun(); //a=10 b=20 c=30 fun(100); //a=100 b=20 c=30 fun(100,200); //a=100 b=200 c=30 fun(100,200,300); //a=100 b=200 c=300 return 0; } void fun(int a, int b, int c) { std::cout &lt;&lt; a+b+c &lt;&lt; std::endl; } 构造函数和析构函数构造函数和析构函数没有返回值，有返回值是成员函数。 复制构造函数 class Point { public: Point(int xx,int yy){X=xx;Y=yy;} Point(const Point&amp; p); int getX(){returnX;} int getY(){returnY;} private: intX,Y; }; Point::Point(const Point&amp; p) { X=p.X; Y=p.Y; std::cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;std::endl; } int main() { Point p1(1,2); Point p2(p1); return 0; } 内联函数内联函数 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性。 内联函数不能包含循环、递归、switch等复杂操作。 inline void fun(int a) { std::cout&lt;&lt; a &lt;&lt;std::endl; } int main() { int x = 1; fun(x); //相当于执行std::cout&lt;&lt; x &lt;&lt;std::endl; return 0; } 引用 引用必须初始化，初始化后无法再去引用另一个对象 引用后具有该数据类型的所有操作 int main() { int a = 1; int &amp;b = a; b++; std::cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt;endl; //a=2, b=2 return 0; } 内存管理new(申请) / delete（释放） 使用 new 申请内存，使用 delete 释放内存 申请内存需要判断是否成功，释放内存需要设空指针 new 与 delete 配套使用 int main() { int *p = new int; //申请内存 int *arr = new int[10]; //申请块内存 //赋值、输出 *p = 2; std::cout &lt;&lt; *p &lt;&lt;std::endl; for(int i = 0; i &lt; 10; i++) { arr[i] = i; std::cout &lt;&lt; arr[i] &lt;&lt;std::endl; } //释放内存 delete p; //释放p p = NULL; //置空p delete []arr; //释放arr arr = NULL; //置空arr //申请大内存 int *q = new int[10000]; if(NULL == q) { std::cout &lt;&lt; &quot;内存分配失败&quot; &lt;&lt;std::endl; } else { std::cout &lt;&lt; &quot;内存分配成功&quot; &lt;&lt;std::endl; } delete []q; //释放 q = NULL; //置空 } 类抽象类含有纯虚函数的类叫做抽象类。 只有实现了抽象类全部纯虚函数的子类才可以创建对象。 接口类仅含有纯虚函数的抽象类叫做接口类。 聚合类用户可以直接访问其成员，并且具有特殊的初始化语法形式。 满足如下特点： 所有成员都是public 没有有定于任何构造函数 没有类内初始化 没有基类，也没有virtual函数 如下： //定义： struct Date { int ival; string s; } //初始化： Data vall = { 0, &quot;Anna&quot; }; 字面值常量类数据成员都是字面值类型的聚合类是字面值常量类 访问限定符 public ： 公共的 protected ： 受保护的 private : 私有的 对象对象的实例化 从栈中实例化 A a; A a[10]; 从堆中实例化 A *p = new A(); //Tips：与 A *p = new A; 一样 A *q = new A[10]; Tips：对象指针 = new 类名（&lt;初始值列表&gt;）;当A的构造函数没有参数可以省略括号；当A的构造函数有参数是不能省略括号，而且要填写传入参数。 对象的拷贝 浅拷贝——只是对象数据的拷贝（指针类型拷贝到的是地址） 深拷贝——对对象本身进行重新构建（指针类型重新开辟内存进行拷贝数据） new 与 malloc 的不同 new 会调用对象的构造函数，malloc不会，仅仅分配内存。 初始化列表 http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。 初始化列表是构造函数进行初始化的一种方式，在构造函数后面以冒号开头，后跟一系列以逗号分隔的初始化字段。 class Animal { public: Animal(int weight,int height): //A初始化列表 m_weight(weight), m_height(height) { } Animal(int weight,int height) //B函数体内初始化 { m_weight = weight; m_height = height; } private: int m_weight; int m_height; } tips：A与B不能同时存在 使用初始化列表的好处： 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。 operator操作符含义operator是操作符的意思。它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。 运算符重载的本质是函数的重载 一元运算符重载1.（负号）- 的重载 友元函数重载 class Coordinate { friend Coordinate&amp; operator-(Coordinate &amp;coor); //友元函数 public: Coordinate(int x, int y); private: int m_ix; int m_iy; } Coordinate&amp; Coordinate::operator-(Coordinate &amp;coor) { coor.m_ix = -coorm_ix； coor.m_iy = -coor.m_iy； return *this; } int main() { Coordinate coor1(3,4); -coor1; //相当于operator-(coor1); return 0; } 成员函数重载 class Coordinate { public: Coordinate(int x, int y); Coordinate&amp; operator-(); //成员函数 private: int m_ix; int m_iy; } Coordinate&amp; Coordinate::operator-() { m_ix = -m_ix； m_iy = -m_iy； return *this; } int main() { Coordinate coor1(3,4); -coor1; //相当于coor1.operator-(); return 0; } 2. (自增) ++ 的重载 前置 ++ 符号重载（成员函数重载） class Coordinate { public: Coordinate(int x, int y); Coordinate&amp; operator++(); //前置++ private: int m_ix; int m_iy; } Coordinate&amp; Coordinate::operator++() { m_ix++； m_iy++； return *this; } int main() { Coordinate coor1(3,4); ++coor1; //相当于coor1.operator++(); return 0; } 后置 ++ 符号重载（成员函数重载） class Coordinate { public: Coordinate(int x, int y); Coordinate&amp; operator++(int); //后置++ private: int m_ix; int m_iy; } Coordinate&amp; Coordinate::operator++(int) { Coordinate old(*this); m_ix++； m_iy++； return old; } int main() { Coordinate coor1(3,4); coor1++; //相当于coor1.operator++(0); return 0; } 二元运算符重载1.（负号）- 的重载 友元函数重载 class Coordinate { friend Coordinate operator+(const Coordinate &amp;c1, const Coordinate &amp;c2); // 重载+ public: Coordinate(int x, int y); private: int m_ix; int m_iy; } Coordinate operator+(const Coordinate &amp;c1, const Coordinate &amp;c2) { Coordinate temp; temp.m_ix = c1.m_ix + c2.m_ix； temp.m_iy = c1.m_iy + c2.m_iy； return temp; } int main() { Coordinate coor1(3,4); Coordinate coor2(5,6); Coordinate coor3(0,0); coor3 = coor1 + coor2; //相当于operator+(coor1, coor2); return 0; } 成员函数重载 class Coordinate { public: Coordinate(int x, int y); Coordinate operator+(const Coordinate &amp;coor); // 重载+ private: int m_ix; int m_iy; } Coordinate&amp; Coordinate::operator++(const Coordinate &amp;coor) { Coordinate temp; temp.m_ix = this-&gt;m_ix + coor.m_ix； temp.m_iy = this-&gt;m_iy + coor.m_iy； return temp; } int main() { Coordinate coor1(3,4); Coordinate coor2(5,6); Coordinate coor3(0,0); coor3 = coor1 + coor2; //相当于coor1.operator+(coor2); return 0; } 1.（输出）&lt;&lt; 的重载 (用友元函数重载，&lt;&lt; 不可以用成员函数重载)class Coordinate { friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const Coordinate &amp;coor); // 重载&lt;&lt; public: Coordinate(int x, int y); private: int m_ix; int m_iy; } ostream&amp; operator&lt;&lt;(ostream &amp;out, const Coordinate &amp;coor) { out &lt;&lt; coor.m_ix &lt;&lt; &quot;,&quot; &lt;&lt; coor.m_iy； return out; } int main() { Coordinate coor1(3,4); cout &lt;&lt; coor; //相当于operator&lt;&lt;(cout, coor); return 0; } 1.（索引运算符）[] 的重载 (用成员函数重载，[]不能用友元函数重载)class Coordinate { public: Coordinate(int x, int y); int opetator [](int index); private: int m_ix; int m_iy; } int Coordinate::operator [](int index) { if(0 == index) return m_ix; if(1 == index) return m_iy; } int main() { Coordinate coor1(3,4); cout &lt;&lt; coor[0]; //相当于coor.operator[](0); cout &lt;&lt; coor[1]; //相当于coor.operator[](1); return 0; } 功能用法1. 操作符重载（operator overloading） 格式如下：类型T operator 操作符 () template&lt;typename T&gt; class A { public: const T operator + (const T&amp; rhs) //重载 + 号运算符 { return this-&gt;m_ + rhs; } private: T m_; }; 2. 操作隐式转换（operator casting） 格式如下： operator 类型T () class A { public: operator B* () { return this-&gt;b_;} operator const B* () {return this-&gt;b_;} operator B&amp; () {return *this-&gt;b_;} private: B* b_; }; A a; //当if(a)，编译时，其中它转换成if(a.operator B*())，其实也就是判断 if(a.b_) 面向对象特征——封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 关键字：public, protected, friendly, private。不写默认为 friendly。 关键字 当前类 包内 子孙类 包外 public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × class A { public: ... protected: ... private: ... } 继承 基类（子类）——&gt; 派生类（父类） 多态 多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。多态性在C++中是通过虚函数来实现的。 多态是以封装和继承为基础的。 静态多态（早绑定）class A { public: void do(int a); void do(int a, int b); } 动态多态（晚绑定） 用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数不能是虚函数 静态函数不能是虚函数 内联函数不能是虚函数 构造函数不能是虚函数 class Shape //形状类 { public: virtual double calcArea() { ... } } class Circle : public Shape //圆形类 { public: virtual double calcArea(); ... } class Rect : public Shape //矩形类 { public: virtual double calcArea(); ... } int main() { Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-&gt;calcArea(); //调用圆形类里面的方法 shape2-&gt;calcArea(); //调用矩形类里面的方法 return 0； } 虚析构函数 class Shape { public: Shape(); //构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); //虚析构函数 } class Circle : public Shape //圆形类 { public: virtual double calcArea(); ... } int main() { Shape * shape1 = new Circle(4.0); shape1-&gt;calcArea(); delete shape1; //因为是虚析构函数，所以调用子类析构函数后，也调用父类析构函数。 shape1 = NULL; return 0； } 纯虚函数 （含有纯虚函数的类叫做抽象类） virtual int A() = 0; 运行时类型识别（RTTI）class Flyable //【能飞的】 { public: virtual void takeoff() = 0; //起飞 virtual void land() = 0; //降落 } class Bird : public Flyable //【鸟】 { public: void foraging() {...} //觅食 virtual void takeoff() {...} virtual void land() {...} } class Plane : public Flyable //【飞机】 { public: void carry() {...} //运输 virtual void take off() {...} virtual void land() {...} } class type_info { public: const char* name() const; bool operator == (const type_info &amp; rhs) const; bool operator != (const type_info &amp; rhs) const; int before(const type_info &amp; rhs) const; virtual ~type_info(); private: ... } class doSomething(Flyable *obj) //【做些事情】 { obj-&gt;takeoff(); cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; //输出传入对象类型（Bird or Plane） if(typeid(*obj) == typeid(Bird)) //判断对象类型 { Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); //对象转化 bird-&gt;foraging(); } obj-&gt;land(); } dynamic_cast 注意事项： 只能应用于指针和引用的转化 要转化的类型中必须包含虚函数 转化成功返回子类的地址，转化失败返回NULL typeid 注意事项： type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 异常处理try{ ... }catch(Exception e){ ... } throw ... 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 预处理预处理器： 预处理器是为了确保头文件多次包含仍能安全工作的常用的技术。 头文件保护符： #define //把一个名字设定为预处理变量 //检查某个指定的预处理变量是否已经定义 #ifdef //当且仅当变量已定义时为真 #ifndef //当且仅当变量已定义时为真 #endif //检查结果为真，则执行到endif为止 #ifndef SALES_DATA_H #define SALES_DATA_H #include &lt;string&gt; struct Sales_data{ std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; #endif 空指针: 以往程序使用名为NULL的预处理变量（这个变量在头文件cstdlib中定义，值为0）； 在C++11新标准中最好使用nullptr，同时尽量避免使用NULL，如： int *p = nullptr; 其他C++中的struct和class的区别 http://blog.sina.com.cn/s/blog_48f587a80100k630.html 最本质(唯一)的一个区别就是默认的访问控制1）默认的继承访问权限。struct是public的，class是private的。2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 总的来说，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。 C/C++中struct和class的区别： http://genwoxuec.blog.51cto.com/1852764/503334 struct和typedef struct http://www.cnblogs.com/qyaizs/articles/2039101.htmlhttp://blog.csdn.net/haiou0/article/details/6877718]]></content>
    </entry>

    
  
  
</search>
