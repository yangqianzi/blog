<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[QT QDialog 中模态与非模态对话框的研究]]></title>
      <url>%2F2017%2F06%2F29%2FQTQDialogModal%2F</url>
      <content type="text"><![CDATA[模态与非模态对话框模态对话框模态对话框是只能首先对其进行操作后才能操作其他窗口的对话框。实质是父线程在子线程创建这个模态对话框后，父线程阻塞，等待子线程的操作。 非模态对话框非模态对话框则是可以同时对它和其他窗口进行操作的对话框。实质是父子进程并行运行。 QDialog概述 The QDialog class is the base class of dialog windows. QDialog 类是对话框窗口的基类。用于创建对话窗口。 继承关系class Q_WIDGETS_EXPORT QDialog : public QWidget QT 窗口模态（Qt::WindowModality）模态种类enum WindowModality { NonModal, WindowModal, ApplicationModal }; 状态 Constant Value 描述 QDialog代表方法 非模态 Qt::NonModal 0 窗口不是模态，不会阻止其他窗口的操作 QDialog::show() 窗口模态 Qt::WindowModal 1 窗口对单个窗口层次结构是模态，会阻止对其所有长辈（父窗口、祖父窗口、他们的兄弟姐妹）的操作，其子窗口不会阻止 QDialog::open() 应用模态 Qt::ApplicationModal 2 窗口对应用程序是模态，并阻止对所有窗口的操作 QDialog::exec() 注意：窗口模态与应用模态都属于模态，只是WindowModal对局部模态，ApplicationModal对整个程序模态。 设置模态定义class Q_WIDGETS_EXPORT QWidget : public QObject, public QPaintDevice { public: void setWindowModality(Qt::WindowModality windowModality); } 使用QDialog dialog; dialog.setWindowModality(Qt::ApplicationModal);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机会总是留给有准备的人 —— 从裁缝到码农]]></title>
      <url>%2F2017%2F06%2F14%2FChanceLeftPerson%2F</url>
      <content type="text"><![CDATA[序言2014年8月，一个男生拿着广工服装工程专业的录取通知书来到东风路，望着学校大门，想着：“这就是我的大学？” 2014年11月，一个男生一个女生望着广工大学城的大门，女生憧憬着：“别人家的大学真漂亮呀”，男生笑了：“对呀，别人家的大学真漂亮。” 2016年8月，一个男生拿着一张转专业通知书路过广工大学城大门，驻足远望，想着：“这就是我的大学！” 裁缝，我没准备依稀记得高考填自愿的那年夏天，闷热的风吹躁了我的心。老师和长辈们都说，先选学校，再选专业。你出去别人首先看你的学校，并且大学基本上靠自学，还可以修双专业，所以专业不重要。那时，我还不知道大学是什么样子，只是一腔热血地喜欢计算机，也只知道许多大神都是自学甚至辍学的。因此，我在第一志愿广工的最后一栏填了“服从调配”四个字。就是这四个轻率毫无准备的字，让我走上一条野路。 录取通知出来了，我两眼呆滞地看着那行录取信息，广东工业大学，艺术设计学院，服装设计与工程。我内心瞬间模拟了一次宇宙大爆炸，颤抖地扶着墙，缓慢移出房间，告诉父母我被广工录取了，专业是……是那什么鬼呀？ 我费了好一会儿功夫才模糊知道这个专业是做什么的。服装设计与工程，就是设计衣服加做衣服。那一刻，我后悔了。我想起高三桌子右上角的座右铭，是在《仙剑》看到的“我命由己不由天”，而此时，我似乎听到了老天的奸笑，“嘿嘿，小子，这就是你的命”。 我没准备，因此录了服装工程。我对自己说，你不是说自学都行吗？自己选的路，跪着也要走完！野路子出身也能成为大神！ 码农，我准备着就这样，我来到了东风路，来到了我的大学。破冰，军训，选班干，加社团，搞活动，交朋友，到处玩，到处浪。大学丰富多彩的活动吸引着我，让我暂时忘却烦恼。等到渐渐习惯大学的生活后，作为新生的激情归于沉寂，随之而来的就是深深地迷茫。 你问可以转专业吗？我也问过辅导员，辅导员说基本上不可以，虽然学生手册中有这种操作，但是他还没见过有人转成功过，因为学校还没有明确的政策。有人问我为什么不试着喜欢上这个专业呢？我想了想，说：“就像喜欢一个人，一旦喜欢上，心就容不下别人”。 自学计算机？要学什么？怎么学？学了以后有出路吗？黑夜不可怕，最可怕的是没有黎明的黑夜。我迷茫着。 幸好，我遇到了个很好的思修老师，她讲的关于“梦想、理想、方向”的理解让我有种醍醐灌顶的感觉。虽然我梦想很远，甚至看不到，那我就只需要朝着这个方向努力，为此准备着，等到时机成熟，量变引起质变的时候，就会发现，其实，梦想触手可及。 就这样，我带着一抹执念，走上一条野路。从谭浩强的《C程序设计》，到郝斌的C语言、数据结构教程，我初窥编程门径。想着杨昌济对毛泽东说的：“修学储能,先博后渊”，我就真的傻傻的“博”学了遍，学了C++、Java，也学了前端、安卓，甚至还玩了单片机。现在想想真是后悔死了，学而不精等于没学。 但是，不管怎样，我还是在这条野路上走着、准备着，即使走得慢，即使走了弯路，即使看不到希望。 转专业，我准备了大二下的某一天，我意外地知道了学校今年有转专业的政策，我内心似乎有股火苗在燃烧，我不相信，当即去问辅导员，等到确认后心还是躁动着。慢慢地，我又有些担忧，转专业呀，听说都要专业第一第二名的水平呀，我一个不怎么学服工自学计算机的，不会绩点就不达标吧。当机会摆在我眼前的时候，我是否有能力抓住？仔细想想，看来我准备地还不够呢。我还是交了转专业申请表，不报白不报嘛，万一成功了呢。 转专业考核的内容是C语言和离散数学。离散是没有学过的，所以我就开始自学了。离散的一堆概念真是令人头疼，好在一位计算机学院的同学给了我离散往年题目，才慢慢学完。 考核分两轮：绩点和笔试面试。第一轮绩点刷人，我和一老哥并列最后，因为刚开始施行这个政策，转专业人的绩点还没高到那种程度呢，好险！第二轮的笔试，和我并列的那老哥竟然C和离散之前都没学过，只是狂看了几天就来考核了，我服！原来他之前不知道考核内容，但当时已经在一家公司搞着前端项目了。面试的时候，我当天机智的穿了印有 Google Logo 的衣服，吹着我的信仰，结果面试官果然被我的人(zou)格(gou)魅(si)力(yun)折服，最终我以笔试面试总成绩专业第一被录取了！ 看到结果的那一刻我的心快要跳出来了，我不敢相信，害怕这美丽的梦，触碰就破碎。我伸出颤抖的手去抓，发现曾经遥不可及的梦想，经过坚持和努力之后，真的可以抓住。我把它抓在手心，紧紧地。 未来，我准备着现在，我已经在广工大学城计算机专业读了快一年了。因为专业跨度大，需要重读一年大二并补上大一的课，每天的课也满满的，却也充实。 来到这边才发现，在计算机这种专业性质强的专业，科班与非科班的差距还是很大的。师资力量、设备环境、专业指导等都是非科班、野路子所接触不到的，但是我觉得最大的差距还是人脉、氛围、眼界。在服工，根本没有这个氛围，也不知道他们计算机专业每天都在学些什么，唯有一个人摸索，唯有去网上找答案，这让我觉得恐怖也庆幸。 在这边，我进了工作室，有了以后的方向，也开始写博客，玩 Github ，越来越发现身边有很多大神，越来越发现我只是略懂皮毛，越来越发现原来我之前走的很多路都是弯路。 但是，不管怎样，我还是在这条路上走着、准备着，即使走得慢，即使走了弯路，但我总算有了伙伴，有了希望。 未来，我准备着，你准备了吗？ 以下不作为正文，仅以我的经验总结出的几点感悟，望共勉： 机会总是留给有准备的人 当机会摆在你眼前的时候，你是否有能力抓住？ 信息很重要 自己选的路，跪着也要走完！ 现在的社会需要的是精一而不是通百的人才（天才除外） 虽然梦想很远，甚至看不到，那就只需要朝着这个方向努力，为此准备着，等到时机成熟，量变引起质变的时候，就会发现，其实，梦想触手可及。 修电脑的裁缝酱 2017年06月14日于广东工业大学]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT 无法链接动态库 dyld library not loaded ... libhdf5.100.dylib]]></title>
      <url>%2F2017%2F06%2F05%2FQtDyldLibraryNotLoaded%2F</url>
      <content type="text"><![CDATA[qt dyld library not loaded …/libhdf5.100.dylib 分析无法链接动态库，考虑手动添加链接。 找到 libhdf5.100.dylib 文件及路径 /usr/local/opt/hdf5/lib 添加到 QT Run Environment把路径添加到Run Environment中的DYLD_LIBRARY_PATH变量的值中。 若无此变量则添加，若已有则按编辑并在后面加上路径。 Run! 补充：添加到构建设置-构建环境中如果添加到 Run Environment 中还是不行，可以添加到Build-构建设置-构建环境中。 Debug! Thanksstackoverflow . qt mac osx 10.8 dyld: library not loaded…image not found]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 构建静态文件无法生成 index.html 等文件]]></title>
      <url>%2F2017%2F05%2F13%2FHexoNPMERR%2F</url>
      <content type="text"><![CDATA[hexo g 无法生成 index构建情况如下图： 但是一些文件没有生成，如 index.html 文件。 查看 npm 安装各 hexo 插件的情况npm ls --depth 0 hexo 的一些插件未安装插件npm ERR! missing npm ERR! missing hexo-generator-archive… 解决逐一安装缺失的包 npm install hexo-generator-archive --save ... 安装完后重新构建即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写一（插件框架）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_1_Framework%2F</url>
      <content type="text"><![CDATA[唠叨本文唠叨了些CloudComapre这个开源软件的插件编写。 虽然这篇是入门教程，但是作为一只有梦想的程序猿，怎能像很多入门教程那样写个残缺的入门教程呢！ 所以这是一个完整插件的入门教程，我们要写的插件是qSAF(Scan Angle Filter)，这是可以过滤给定范围内点的扫描角度的插件。 下面分三篇来介绍，分别是插件框架篇、数据结构篇、算法实现篇。 这是第一篇，插件框架篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF CloudComapreCloudComapre是一个开源的3D点云和网格的处理软件，开可以处理各类点云格式的数据。 官网：http://www.cloudcompare.org/ Github：https://github.com/cloudcompare/cloudcompare CloudComapre插件编写使用qDummyPlugin插件模板创建自己的插件首先在Github上git下CloudComapre的源码， 再到 CloudComapre/plugins/qDummyPlugin 下 这个qDummyPlugin就是个插件的模板，用它来写自己的插件。 我们把这个模板插件文件夹拷贝一份，改为自己的插件名qSAF（当然，你也可以改为其他你喜欢的，以下不做累述） 现在qSAF里面有如下几个文件 我们需要做的是把里面的qDummyPlugin及类似的名字改为自己的qSAF。 注意：文件名和文件里面内容都要修改！ 如： 原本CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) #REPLACE ALL &apos;DUMMY&apos; OCCURENCES BY YOUR PLUGIN NAME #AND ADAPT THE CODE BELOW TO YOUR OWN NEEDS! option( INSTALL_QDUMMY_PLUGIN &quot;Check to install qDUMMY plugin&quot; OFF ) # CloudCompare &apos;DUMMY&apos; plugin if (INSTALL_QDUMMY_PLUGIN) project( QDUMMY_PLUGIN ) #load necessary libraries (see qPCV for an example) #add_subdirectory (LIB1) #if the plugin is an &apos;OpenGL filter&apos;, uncomment the line below #set( CC_OPENGL_FILTER ON BOOL) include( ../CMakePluginTpl.cmake ) #set dependencies to necessary libraries (see qPCV for an example) #target_link_libraries( ${PROJECT_NAME} LIB1 ) #include_directories( ${LIB1_INCLUDE_DIR} ) endif() 修改后的CMakeLists.txt文件里面是这样的： cmake_minimum_required(VERSION 3.0) option( INSTALL_QSAF_PLUGIN &quot;Check to install qSAF plugin&quot; OFF ) if (INSTALL_QSAF_PLUGIN) #CloudCompare ‘SAF’ plugin project( QSAF_PLUGIN ) include( ../CMakePluginTpl.cmake ) endif() 剩下的qSAF.h、qSAF.cpp和qSAF.qrc就不一一列出了 修改后变成这样： 使用qmake构建pro文件在终端进入到你的插件的qSAF目录，执行： qmake -project -r CMakeLists.txt 就会在qSAF目录下构建一个项目的pro文件。 导入工程到QT现在把CloudComapre导入到QT， 在CloudComapre-plugins-plugins.pro中，加上自己的插件： 保存刷新后就会在项目上看到了。 pro文件编写由于qmake自动生成的pro文件不适合我们要写的插件，所以要自己修改pro文件。 pro文件的编写可以参考： QT的pro文件编写 里面的常规pro文件就是qSAF的。 里面的路径可以不用修改，具体看你项目的Release生成的位置， 特别注意：指定生成路径中的libs和plugins要正确 完成模板插件框架没错！这就完成了，你的插件已经做出来了！现在可以Run一下或者Debug一下看看啦~ 选中点云，使用qSAF，会这样： 莫慌！这是正常现象，因为你的qSAF具体实现还没有写呢！ 遇到问题1. 编译出错可能原因： qSAF.h、qSAF.cpp和qSAF.qrc这三个文件里面的qDummyPlugin及类似的名字要改为自己的qSAF，如果改错或没改，可能报错。 自己写的代码有错，这个视情况而定 2. 运行的CloudComapre插件上没有你编写的插件的快捷方式可能原因 插件的生成路径出错了，自己插件的pro文件中的plugins指定生成路径要正确。 个性化插件现在来个性化一下我们的插件 在qSAF.h中： // 设置插件的唯一ID Q_PLUGIN_METADATA(IID &quot;cccorp.cloudcompare.plugin.qSAF&quot;) // 设置插件名字 virtual QString getName() const override { return &quot;SAF&quot;; } // 设置插件的描述 virtual QString getDescription() const override { return &quot;Filter the scanning angle in a range of points&quot;; } // 设置插件图标，这个要在 qSAF.cpp 里设置图标路径 virtual QIcon getIcon() const override; // 设置插件要执行的操作（重点） void doAction(); 插件doAction()我们编写插件是要做些事情，在CloudComapre插件中就是在doAction()中实现按下插件SAF后要做的事。 这个函数在qSAF.cpp中，你会发现复制的模板插件的doAction()是这样的（把qDummyPlugin改为qSAF啦）： void qSAF::doAction() { //m_app should have already been initialized by CC when plugin is loaded! //(--&gt; pure internal check) assert(m_app); if (!m_app) return; /*** HERE STARTS THE ACTION ***/ //put your code here //--&gt; you may want to start by asking parameters (with a custom dialog, etc.) //This is how you can output messages m_app-&gt;dispToConsole(&quot;[qSAF] Hello world!&quot;,ccMainAppInterface::STD_CONSOLE_MESSAGE); //a standard message is displayed in the console m_app-&gt;dispToConsole(&quot;[qSAF] Warning: qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::WRN_CONSOLE_MESSAGE); //a warning message is displayed in the console m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); //an error message is displayed in the console AND an error box will pop-up! /*** HERE ENDS THE ACTION ***/ } 我们要做的就是在 /*** HERE STARTS THE ACTION ***/ 下面写自己的插件代码。 刚才你看的错误信息就是这句： m_app-&gt;dispToConsole(&quot;qSAF plugin shouldn&apos;t be used as is!&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 这是控制台输出的错误信息。 错误信息(ERR_CONSOLE_MESSAGE)同时在控制台和窗体形式出现，而其他标准信息(STD_CONSOLE_MESSAGE)、警告信息(WRN_CONSOLE_MESSAGE)，则只在控制台显示。 现在删掉/*** HERE STARTS THE ACTION ***/下面的，改为自己的一句： m_app-&gt;dispToConsole(&quot;[qSAF] 程序是从错误开始的！&quot;,ccMainAppInterface::ERR_CONSOLE_MESSAGE); 结果如下： 插件框架完成现在已经完成了插件框架的编写啦。 其实只要使用CloudComapre提供的插件模板qDummyPlugin，改成自己的就可以啦。 现在可以发挥你的想象力，在doAction()里面随心所欲地做各种事情啦。 但是只有框架还不够，要想对点云进行操作，和SAF功能的具体实现，还需要了解CloudComapre中点云的数据结构： CloudComapre插件编写二（数据结构） 如果你对点云数据结构虐它如虐狗，可以戳这里： CloudComapre插件编写三（算法实现）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写二（数据结构）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_2_DataStructure%2F</url>
      <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第二篇，数据结构篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF 前文概要在上回中，我们已经实现了插件的框架，现在要在doAction()中写插件的具体实现。 插件需求我们要做的是一个qSAF(Scan Angle Filter)插件，它可以过滤给定范围内点的扫描角度。 也就是用户输入两个角度值，如20度、70度， 过滤输出每个点的扫描角度在大于等于20度、小于等于70度的范围的点云。 需求分析要实现这个功能，我们需要有一个界面，可以让用户输入两个角度，然后获取两个角度值，接着遍历每个点，获取每个点的扫描角度，然后获得角度在大于等于20度、小于等于70度范围的点云，显示输出。 简单地说，就是要： 输入界面 遍历角度 输出点云 1. 输入界面是QT基础；3. 输出点云是CC套路；只有2. 遍历角度有点纠结。 因此本文第二篇主要介绍2. 遍历角度，即介绍点云中点的数据结构。 注意：不同类型文件的数据结构不同，本文以激光雷达文件(.las)来做介绍。 las文件的读入首先，我们从宇宙的起源开始说起…… 额，还是从.las文件的读入开始说起吧~ .las文件的读入首先进过FileIOFilter这个类，判断是雷达文件(.las)后，进入LASFilter类，并从它的loadFile()函数读入。 先看下loadFile()函数声明： virtual CC_FILE_ERROR loadFile(QString filename, ccHObject&amp; container, LoadParameters&amp; parameters) override; 特别注意三个传入参数！我就是忽视了这里才找了好久。。。 QString filename 是点云文件名（包括路径） ccHObject&amp; container 是一个实体（ccHObject），可以添加点云（ccPointCloud） LoadParameters&amp; parameters 是选择读入文件后提示要勾选雷达的哪些信息 然后看下loadFile()函数体 .las文件首先从io流读入，再使用liblas这个外部库存储： liblas::Reader reader(liblas::ReaderFactory().CreateWithStream(ifs)); 这里说下liblas： liblas是用于读取和编写非常常见的LAS LiDAR格式的C/C++库，我们使用它来做对LAS的直接读取。 官网如下： https://www.liblas.org/ 然后把liblas读入的文件进行各种处理和封装，最终封装成ccPointCloud ccPointCloud* loadedCloud = 0; int sfIndex = loadedCloud-&gt;addScalarField(field-&gt;sf); ... loadedCloud-&gt;setName(chunkName); ... loadedCloud-&gt;setMetaData(LAS_SCALE_X_META_DATA, QVariant(lasScale.x)); ... loadedCloud-&gt;addPoint(P); ... 然后通过： container.addChild(loadedCloud); 添加到ccHObject中 所以：点云的信息，都是存储在ccPointCloud中的！ 而扫描角度存储在ccPointCloud的标量域中(ccScalarField) ccPointCloud前面已经说了很多ccPointCloud了，它就是CloudCompare中存储点云的类。 我们看看它的说明 //! A 3D cloud and its associated features (color, normals, scalar fields, etc.) /** A point cloud can have multiple features: - colors (RGB) - normals (compressed) - scalar fields - an octree strucutre - per-point visibility information (to hide/display subsets of points) - other children objects (meshes, calibrated pictures, etc.) **/ 我要的扫描角度就在scalar fields 然而在ccPointCloud没有直接的方法获得众多标量域中的扫描角度 终于在它的父类ChunkedPointCloud中发现了 ChunkedPointCloudccPointCloud的父类ChunkedPointCloud中有如下两个函数： # 通过标量域名字获得其在标量域数组中的索引 int ChunkedPointCloud::getScalarFieldIndexByName(const char* name) const # 通过索引获得特定标量域的指针 ScalarField* ChunkedPointCloud::getScalarField(int index) const 通过这两个函数就可以获得指向扫描角度的指针了，要想访问扫描角度中每个点的值，需要使用ScalarField父类GenericChunkedArray的方法 GenericChunkedArray# 通过每个点的索引访问特定标量域的每个的的值 inline const ElementType* getValue(unsigned index) const LASOpenDlg标量域中扫描角度的名字可以在LASOpenDlg.h中找到 &quot;Scan Angle Rank&quot; 整理下思路 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 这样就获取到了每个点的扫描角度值，然后： 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 上面整理的思路在下篇实现，现在我们已经知道怎么获取点云中扫描角度的值了，那其他信息呢？ 点云其他信息的获取看下在QT的调试信息： 我们可以发现，其实点云的信息都能在ccPointCloud中获取，比如点容量、点数量、点坐标、标量域、颜色值等。 其中，标量域vector中有9项信息，存储的标量域顺序为： [0] Point Source ID [1] Scan Angle Rank [2] Flightline Edge [3] Scan Direction [4] Number of Returns [5] Return Number [6] Time [7] Intensity [8] Classification 至于如何获取每种数据，都有相应的方法实现，不是在ccPointCloud，就是在它的父类中，耐心点总能找到的~ 下篇概要下篇是算法实现篇，主要说了qSAF插件的具体实现，包括上面说的： 输入界面 遍历角度 输出点云 请戳这里： CloudComapre插件编写三（算法实现）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare插件编写三（算法实现）]]></title>
      <url>%2F2017%2F04%2F27%2FCloudCompareSAFPlugin_3_Algorithm%2F</url>
      <content type="text"><![CDATA[唠叨本文分三篇来介绍一个完整的CloudComapre插件的编写教程，分别是插件框架篇、数据结构篇、算法实现篇。 这是第三篇，算法实现篇，你可以根据本文改成自己的插件，待卿临幸。 qSAF源码：Github . qSAF 前文概要在上回中，我们知道了点云中扫描角度的存储结构，下面我们来讲qSAF的具体实现。 UI界面新建QT设计器界面类，命名为ccSAFDlg，在ccSAFDlg.ui文件设计简单的界面。 因为我们只需要一个范围，一个确认取消键，所以我把它弄成这样子： doubleSpinBox要设置范围：0.00到90.00，默认值分别设为20.00和70.00。 ccSAFDlg.h： #ifndef CCSAFDLG_H #define CCSAFDLG_H #include &quot;ui_SAFDlg.h&quot; #include &lt;QDialog&gt; namespace Ui { class ccSAFDlg; } class ccSAFDlg : public QDialog, public Ui::ccSAFDlg { Q_OBJECT public: explicit ccSAFDlg(QWidget *parent = 0); protected slots: //! Saves (temporarily) the dialog paramters on acceptation void saveSettings(); }; #endif // CCSAFDLG_H ccSAFDlg.cpp： #include &quot;ccSAFDlg.h&quot; //定义两个静态阈值，并初始化 static double threshold_1 = 20; static double threshold_2 = 70; ccSAFDlg::ccSAFDlg(QWidget *parent) : QDialog(parent), Ui::ccSAFDlg() { setupUi(this); //关联信号槽 connect(buttonBox, SIGNAL(accepted()), this, SLOT(saveSettings())); //初始化设置阈值 doubleSpinBox_1-&gt;setValue(threshold_1); doubleSpinBox_2-&gt;setValue(threshold_2); } void ccSAFDlg::saveSettings() { //OK后重新赋值 threshold_1 = doubleSpinBox_1-&gt;value(); threshold_2 = doubleSpinBox_2-&gt;value(); } 现在界面就做好了。 插件doAction实现至于doAction的实现，点云其中的数据结构，可以参考第二篇，数据结构篇 简单地说，我们需要： 用Scan Angle Rank，通过getScalarFieldIndexByName()获得扫描角度在标量域中的索引 用索引，通过getScalarField()获得扫描角度标量域指针 用指针，通过getValue()获得每个点的值 比较扫描角度值与用户输入区间的大小，把合适的值存储起来 把合适值封装成点云实体 显示在界面上 大体的算法思路上是没有问题的，但是有个纠结的地方，就是是否使用进度条。 实测SAF处理一个雷达文件， 使用进度条耗时：129.1s 不用进度条耗时：3.5s 这种压倒性的差距让我果断砍掉真·进度条，没错！我使用假·进度条，就是不会动的进度条。 这样短时间的处理使用假·进度条，既不会降低处理速度，也不会降低用户体验~ 下面就是完整代码，注释中有真·进度条的实现（[进度条]），但不推荐使用 void qSAF::doAction() { //当插件加载时，m_app应该已经被CC初始化了 assert(m_app); if (!m_app) return; //获取选择的实体 const ccHObject::Container&amp; selectedEntities = m_app-&gt;getSelectedEntities(); //获取选择的实体数量 size_t selNum = selectedEntities.size(); //确保只选择一个实体 if (selNum != 1) { m_app-&gt;dispToConsole(&quot;[SAF] Select only one cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } ccHObject* ent = selectedEntities[0]; assert(ent); //确保选择的实体是POINT_CLOUD类型 if (!ent || !ent-&gt;isA(CC_TYPES::POINT_CLOUD)) { m_app-&gt;dispToConsole(&quot;[SAF] Select a real point cloud!&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //从选择的实体中转换成ccPointCloud*类型 ccPointCloud* pc = static_cast&lt;ccPointCloud*&gt;(ent); //获取点云的数量m_count unsigned count = pc-&gt;size(); //初始化阈值变量 static double threshold_1 = 20; static double threshold_2 = 70; double threshold_temp = 0; //显示插件ui窗体 { ccSAFDlg safDlg(m_app-&gt;getMainWindow()); safDlg.doubleSpinBox_1-&gt;setValue(threshold_1); safDlg.doubleSpinBox_2-&gt;setValue(threshold_2); if(!safDlg.exec()) { return; } //存储阈值 threshold_1 = safDlg.doubleSpinBox_1-&gt;value(); threshold_2 = safDlg.doubleSpinBox_2-&gt;value(); } //显示进度条窗体 QProgressDialog pDlg; pDlg.setWindowTitle(&quot;SAF&quot;); pDlg.setLabelText(QString(&quot;Scan Angle Filter\nfrom %1 to %2&quot;).arg(threshold_1).arg(threshold_2)); //[进度条]设置进度条总范围 //pDlg.setRange(0, count); pDlg.setCancelButton(0); pDlg.show(); QApplication::processEvents(); QElapsedTimer timer; //计时开始 timer.start(); ScalarType scanAngle; CCLib::ReferenceCloud rangeAnglerc(pc); //确保 threshold_1 小于 threshold_2 if(threshold_1 &gt; threshold_2) { threshold_temp = threshold_1; threshold_1 = threshold_2; threshold_2 = threshold_temp; } //[进度条]进度条的取消SAF按钮 //bool wasCancelled = false; //获取 Scan Angle Rank 的索引 int scanAngleSFIndex = pc-&gt;getScalarFieldIndexByName(&quot;Scan Angle Rank&quot;); //[重点]遍历每个点的操作 for(unsigned i = 0; i &lt; count; ++i) { //获取每个点的扫描角度 scanAngle = pc-&gt;getScalarField(scanAngleSFIndex)-&gt;getValue(i); //取扫描角度的绝对值 if(scanAngle &lt; 0) { scanAngle = -scanAngle; } //如果扫描角度在给定的阈值范围，则添加它的索引到参考云 if(threshold_1 &lt;= scanAngle &amp;&amp; scanAngle &lt;= threshold_2) { rangeAnglerc.addPointIndex(i); } // //[进度条]重置进度条 // pDlg.setValue(i); // QCoreApplication::processEvents(); // //[进度条]取消SAF处理 // if (pDlg.wasCanceled()) // { // wasCancelled = true; // break; // } } //把 ReferenceCloud 类型克隆成 ccPointCloud 类型 ccPointCloud* rangeAnglepc = pc-&gt;partialClone(&amp;rangeAnglerc); //判断rangeAnglepc是否为空，即所选范围内是否有点 if(!rangeAnglepc) { m_app-&gt;dispToConsole(&quot;[SAF] Failed to extract the range angle subset.&quot;, ccMainAppInterface::ERR_CONSOLE_MESSAGE); return; } //计算SAF后点数所占的百分比和SAF过程所花的时间 m_app-&gt;dispToConsole(QString(&quot;[SAF] %1% of scan angle points are filtered&quot;).arg((rangeAnglerc.size() * 100.0) / count, 0, &apos;f&apos;, 2), ccMainAppInterface::STD_CONSOLE_MESSAGE); m_app-&gt;dispToConsole(QString(&quot;[SAF] Timing: %1 s.&quot;).arg(timer.elapsed() / 1000.0, 0, &apos;f&apos;, 1), ccMainAppInterface::STD_CONSOLE_MESSAGE); //关闭进度条 pDlg.close(); QApplication::processEvents(); // //[进度条]取消SAF // if (wasCancelled) // { // m_app-&gt;dispToConsole(&quot;[SAF] SAF was cancelled&quot;, ccMainAppInterface::STD_CONSOLE_MESSAGE); // return; // } //隐藏原始点云 pc-&gt;setEnabled(false); //添加新的一组DB实体 ccHObject* cloudContainer = new ccHObject(pc-&gt;getName() + QString(&quot;_saf&quot;)); //设置新点云并添加到实体 rangeAnglepc-&gt;setVisible(true); rangeAnglepc-&gt;setName(&quot;SAF Point Cloud&quot;); cloudContainer-&gt;addChild(rangeAnglepc); //添加实体到DB树 m_app-&gt;addToDB(cloudContainer); //刷新 m_app-&gt;refreshAll(); } 效果 结语经过了三篇的学习，终于实现了个完整的插件。 回顾我们学习的路线：插件框架 -&gt; 数据结构 -&gt; 算法实现 我们不仅从中学会了CC插件的编写，也学到了QT的pro文件编写、QT界面设计、CC运作流程、点云数据结构等。 而我在学习这个插件编写的过程收获更多，因为我是看代码两个月，写代码两小时，Debug两天（差不多啦~不要纠结为什么222~） 看代码的过程是非常痛苦的，CC里面大量的模板编程思想，接口设计思想，还有去他继承谁爸爸的爸爸…… 但是期间确实学到很多，以此作为分享，望共勉！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT的pro文件编写]]></title>
      <url>%2F2017%2F04%2F26%2FQTProFile%2F</url>
      <content type="text"><![CDATA[常规pro文件下面是CloudCompare中一个自己写的插件的pro文件， pro文件编写可按照如下方式写。 # 添加QT的模块 QT += widgets \ opengl # 指明让qmake生成哪种makefile文件，app表示应用程序，lib表示库 TEMPLATE = lib # 指明生成的库的名字 TARGET = qSAF # 指明编译依赖路径 DEPENDPATH += .\ # 包含头文件路径 INCLUDEPATH += .\ $$PWD/../ # 工程的头文件路径 HEADERS += qSAF.h \ ../ccStdPluginInterface.h \ ../ccPluginInterface.h \ ../ccMainAppInterface.h \ ccSAFDlg.h # 工程的源文件路径 SOURCES += qSAF.cpp ../ccStdPluginInterface.cpp \ ccSAFDlg.cpp # 工程的资源文件路径 RESOURCES += qSAF.qrc #CC (CloudCompare核心算法库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lCC_CORE_LIB # 包含CC的头文件路径 INCLUDEPATH += $$PWD/../../CC/include # 包含CC的依赖路径 DEPENDPATH += $$PWD/../../CC #qCC_db (CloudCompare数据库路径) win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB else:unix: LIBS += -L$$PWD/../../../Release/libs/ -lQCC_DB_LIB INCLUDEPATH += $$PWD/../../libs/qCC_db DEPENDPATH += $$PWD/../../libs/qCC_db # 工程的ui文件路径 FORMS += \ SAFDlg.ui # Mac系统下，则执行括号内的代码 macx { # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../../Release/libs -Wl #指定生成路径 DESTDIR = $$PWD/../../../Release/CloudCompare.app/Contents/plugins } # Mac外的其他Unix系统下(Linux)，则执行括号内的代码 unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../../Release/libs -Wl,-Bsymbolic #指定生成路径 DESTDIR = $$PWD/../../../Release/plugins } # Windows系统下，则执行括号内的代码 win32 { # windows only }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ IO 库条件状态及EOF]]></title>
      <url>%2F2017%2F04%2F15%2FCppConditionStateAndEOF%2F</url>
      <content type="text"><![CDATA[文本文件判空问题对于空文本文件的判断问题引起了我对 IO 库中条件状态和 EOF 的探究。 就是这段程序： int vehicle_number; fstream infile; infile.open(&quot;vehicle.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; vehicle_number; ...... } infile.close(); } 它可以打开空文本文件并运行到 while(!infile.eof()) 循环里面。由于是空文本文件，它进入里面会造成一些问题，所以需要对文件进行判空。 EOFEOF（End Of File） 常用于： 文件结束标志 函数出错的返回值 在 C++ IO 库中可用作： 条件状态的判定 现在让我们看看 IO 库中的描述。 IO 库条件状态【表一】IO 库条件状态 状态 含义 strm::iostate strm是一种IO类型。iostream是一种机器相关的整型提供了表达条件状态的完整功能 strm::badbit strm::badbit用来指出流已崩溃 strm::failbit strm::failbit用来指出一个IO操作失败了 strm::eofbit strm::eofbit用来指出流达到了文件结束 strm::goodbit strm::goodbit用来指出流未处于错误状态。此值保证为零 s.eof() 流 s 的 eofbit 置位，则返回 true s.fail() 流 s 的 failbit 或 badbit 置位，则返回 true s.bad() 流 s 的 badbit 置位，则返回 true s.good() 若流 s 处于有效状态，则返回 true s.clear() 将流 s 中的所有条件状态位复位，将流的状态设置为有效。返回void s.clear(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位复位。 flag 的类型是strm::iostate。返回 void s.setstate(flag) 根据给定的 flags 标志位，将流 s 中对于条件状态位置位。 flag 的类型是strm::iostate。返回 void s.rdstate() 返回流 s 的当前条件，返回值类型为 strm::iostate 【表二】四种条件状态 状态 含义 数值 good() eof() bad() fail() rdstate() ios::goodbit 流状态完全正常 0 1 0 0 0 goodbit ios::eofbit 已达到文件结束 2 0 1 0 0 eofbit ios::badbit 输入（输出）流出现非致命错误，可挽回 1 0 0 1 0 badbit ios::failbit 输入（输出）流出现致命错误，不可挽回 4 0 0 0 1 failbit 我们先看【表一】的关于 EOF 的这两行： 状态 解释 strm::eofbit strm::eofbit用来指出流达到了文件结束 s.eof() 流 s 的 eofbit 置位，则返回 true 这里指出当流读到文件结束时，eofbit 置 1 ，用于标识读取到文件的末尾。 而 eof() 是当 eofbit 置位（置 1）时才返回，并不是读到文件末尾就返回。 所以使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 文本文件判空问题的解释现在就可以解释最初的问题了，让我们回过头看看。 当程序第一次运行到 while(!infile.eof()) 时，infile.eof() 读到文件末尾的 EOF，但并不是立刻返回 true，只是 eofbit 置位，所以 infile.eof() 还是 false 的状态，所以会进入 while 循环。 文本文件判空问题的解决 把流对象状态当做条件使用 if(infile.is_open()) { while(infile &gt;&gt; vehicle_number) { ...... } } 使用 peek() istream::peek() 用于读取并返回流的下一个字符（返回值为 char 类型），但并不读取该字符到输入流中，即流指针依然指向原来位置，并不后移。 if(infile.is_open()) { while(infile.peek() != EOF) { infile &gt;&gt; vehicle_number; ...... } } 重复读入非空文本文件最后一个字符问题经过上面的解释，我们已经知道了文本文件如何判空。但由于 EOF 的锅，若用 while(!infile.eof()) 还会导致重复读入非空文本文件最后一个字符的问题。 看下面这段代码： char c; fstream infile; infile.open(&quot;test.txt&quot;, ios::in); if(infile.is_open()) { while(!infile.eof()) { infile &gt;&gt; c; cout &lt;&lt; c; } } infile.close(); 和文本文件判空问题的代码相似，只是读入字符存储到 char 类型变量中，并把其输出。 然后我们在 test.txt 中保存 abc 这三个字符。 运行的结果是： abcc 即 while(!infile.eof()) 重复执行了最后一趟，多输入了字符 c 。 这个问题和文本文件判空问题的解决办法一样，都是使用 peek() 或者把流对象当做 while 的条件来解决。 总结 使用 eof() 读取文件，读到结束标志 EOF 时不会立刻返回 true，只是 eofbit 置位，下次调用 eof() 才返回 true。 只有一个流处于无错状态时，我们才可以对它读写数据。因此代码通常应该在使用一个流之前检查它是否处于良好状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Centos 7 挂载 NTFS 分区]]></title>
      <url>%2F2017%2F03%2F29%2FCentos7NTFS%2F</url>
      <content type="text"><![CDATA[NTFS-3G安装使用 NTFS-3G 实现，可以挂载 NTFS，还可以挂载 HFS+ 等，以下是在 Centos 7 下安装 NTFS-3G 及挂载 NTFS 分区 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo sudo yum update sudo yum install ntfs-3g 查看分区fdisk -l 挂载# d、e、f改成你想要挂的盘符名字 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f # d、e、f改成你想要挂的盘符名字，sdb3这些改为要挂的分区 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d mount -t ntfs-3g /dev/sdb4 /mnt/windows/e mount -t ntfs-3g /dev/sdb5 /mnt/windows/f 卸载umount /mnt 设置开机自动挂载sudo vim /etc/fstab #只读式挂载： /dev/sda1 /mnt/windows/c ntfs-3g ro,umask=0222,defaults 0 0 #读写式挂载： /dev/sda1 /mnt/windows/c ntfs-3g rw,umask=0000,defaults 0 0 #或者： /dev/sda1 /mnt/windows/c ntfs-3g defaults 0 0 设置后开机无法启动（无法挂载）网上很多教程都是如上几步就好了~ 然而我的无法开机。 如下图： 这样应该需要输入root密码，用root账户登录修复模式， 然后 vim /etc/fstab 删除刚刚添加的东西， reboot 就能进入系统了 所以之前之前忙活的都没用了？ 后来试了下原来 mount -t ntfs-3g /dev/sdb3 /mnt/windows/d 这句本身就无法挂载！ 然后可以通过 sudo mount -o ro /dev/sdb3 /mnt/windows/d 挂载，但是只能通过终端访问，就是下面这个👇 其他问题无法挂载的解决办法实现了只能在终端访问 #创建挂载点 mkdir /mnt/windows/d mkdir /mnt/windows/e mkdir /mnt/windows/f #挂载分区 sudo mount -o ro /dev/sdb3 /mnt/windows/d sudo mount -o ro /dev/sdb4 /mnt/windows/e sudo mount -o ro /dev/sdb5 /mnt/windows/f #添加上面挂载分区到这里面 sudo vim /etc/rc.d/rc.local #更改权限 chmod +x /etc/rc.d/rc.local Thankshttp://www.cnblogs.com/gbyukg/archive/2011/11/02/2232343.html http://www.jianshu.com/p/f578b575fcaa http://askubuntu.com/questions/462381/cant-mount-ntfs-drive-the-disk-contains-an-unclean-file-system https://www.techbrown.com/mount-ntfs-file-system-centos-7-rhel-7.shtml]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下QT编译输出路径错误：ld unknown option ...]]></title>
      <url>%2F2017%2F03%2F26%2FMacQTCompilerOutputPathError%2F</url>
      <content type="text"><![CDATA[ERROR: ld unknown option rpathMac指定qmake的生成路径时，用 -Wl,-rpath,$$PWD/.. 而不是 -Wl,-rpath=$$PWD/.. 如下： macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl QMAKE_LFLAGS_DEBUG += -Wl,-rpath,$$PWD/../../Release/libs -Wl # 指定生成路径 DESTDIR = $$PWD/../../Release } Linux则用 -Wl,-rpath=$$PWD/.. unix:!macx{ # linux only # 编译时候指定libs查找位置 QMAKE_LFLAGS_RELEASE += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic QMAKE_LFLAGS_DEBUG += -Wl,-rpath=$$PWD/../../Release/libs -Wl,-Bsymbolic # 指定生成路径 DESTDIR = $$PWD/../../Release/libs } ERROR: ld unknown option BsymbolicMac 不支持-Bsymbolic，所以不能这样： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl,-Bsymbolic 应该删去-Bsymbolic，如下： QMAKE_LFLAGS_RELEASE += -Wl,-rpath,$$PWD/../../Release/libs -Wl]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shadowsocks-Qt5 For Centos 7]]></title>
      <url>%2F2017%2F03%2F25%2FShadowsocks-Qt5ForCentos7%2F</url>
      <content type="text"><![CDATA[InstallIf you use the traditional yum package management tool, you need to download the appropriate version of the repo file from the Copr to /etc/yum.repos.d/, and then install through yum. As follows: # Centos 7 wget https://copr.fedorainfracloud.org/coprs/librehat/shadowsocks/repo/epel-7/librehat-shadowsocks-epel-7.repo sudo mv librehat-shadowsocks-epel-7.repo /etc/yum.repos.d/ sudo yum update sudo yum install -y shadowsocks-qt5 Config Explanation of the fields: Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux ProxyGo to Settings-Network-Network proxy, turn on proxy. Use the sock proxy local_address: the address your local listens (default:1080) local_port: local portocal (default:127.0.0.1) Have fun!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CloudCompare功能概要]]></title>
      <url>%2F2017%2F03%2F21%2FCloudCompareFunction%2F</url>
      <content type="text"><![CDATA[File open：打开 save：保存 Global Shift settings：设置最大绝对坐标，最大实体对角线 Primitive Factory：对点云进行原始加工，改变原始点云的形状 3D mouse：对3D鼠标（如3Dconnexion）的支持 Close all：关闭所有打开的实体 Quit：退出 Edit： Clone：克隆选中的点云 Merge：合并两个或者多个实体。可以合并点云（原始云会被删除）；可以合并网格（原始网不会修改，CC会创建一个新的网格结构） Subsample：采集原始点云的子样本，可以用随机、立体、基于八叉树的方式采集，子样本会保持原始点云的标量、颜色、法线等性质。 Apply Transformation：可以对选中的实体做变换（4*4矩阵、轴线角，欧拉角） Multiply / Scale：让选中实体的坐标倍增。 Translate / Rotate (Interactive Transformation Tool)：可以相对于另外一个实体或者坐标系移动选中的实体 Segment (Interactive Segmentation Tool)：通过画2D多边形分隔选中的实体 Crop：分割一个或多个在3D-Box里面的点云。 Edit global shift and scale：进行全局变换和和比例缩放。 Toggle (recursive)：用于控制键盘的快捷键。 Delete：删除选中的实体。 Colors &gt; Set Unique：为所选实体设置唯一一个的颜色 Colors &gt; Colorize：为所选实体着色，具体表现为分别用所选颜色乘以当前颜色的RGB而得到新的颜色 Colors &gt; Levels：通过调整颜色的柱形图变色，类似于Photoshop的Levels方法 Colors &gt; Height Ramp：为所选实体设置颜色渐变（线形、梯形、环形） Colors &gt; Convert to Scalar Field：将当前的 RGB 颜色字段转换为一个或几个标量字段 Colors &gt; Interpolate from another entity：在所选实体中插入另外一个实体的颜色 Colors &gt; Clear：移除所选实体的颜色域 Normals &gt; Compute：计算所选实体的法线 Normals &gt; Invert：反转所选实体的法线 Normals &gt; Orient Normals &gt; With Minimum Spanning Tree：用同样的方法重新定位点云的全部法线（最小生成树） Normals &gt; Orient Normals &gt; With Fast Marching：用同样的方法重新定位点云的全部法线（快速行进法） Normals &gt; Convert to &gt; HSV：将云的法线转换到 HSV 颜色字段 Normals &gt; Convert to &gt; Dip and Dip direction SFs：转换点云的法线到两个标量域 Normals &gt; Clear：为选定的实体移除法线 Octree &gt; Compute：强制计算给定实体的八叉树 Octree &gt; Resample：通过代替每个八叉树单元内的所有点来重新取样 Mesh &gt; Delaunay 2.5D (XY plane)：计算点云在xy平面上的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Delaunay 2.5D (best fit plane)：计算点云在最佳平面的2.5D三角剖分（Delaunay 2.5D triangulation，德洛内2.5D三角算法） Mesh &gt; Convert texture/material to RGB：将选定网格的网格材料和纹理信息转换为逐个点的 RGB 字段 Mesh &gt; Sample points：在一个网格中随机取样 Mesh &gt; Smooth (Laplacian)：平滑一个网格（Laplacian smoothing，拉普拉斯平滑算法） Mesh &gt; Subdivide：细分网格，此算法递归细分网格三角形，直到他们的表面细分到用户指定值之下。 Mesh &gt; Measure surface：测量网格的总体表面积和每个三角形的平均表面积，在控制台输出 Mesh &gt; Measure volume：测量闭合网格的体积，在控制台输出 Mesh &gt; Flag vertices：检查网格的基本特性，为每个网格样本做标志：0 = normal，1 = border，2 = non-manifold Mesh &gt; Scalar field &gt; Smooth：平滑网格顶点相关联的标量场。此方法与高斯滤波（Gaussian Filter）相反。运用qPCV插件后，此方法特别有用 Mesh &gt; Scalar field &gt; Enhance：增强与网格顶点相关联的标量场。运用qPCV插件后，此方法特别有用 Sensors &gt; Edit：修改指定传感器内外在参数 Sensors &gt; Ground Based Lidar &gt; Create：创建’Ground Based Lidar’ (= TLS)传感器实体，附加到所选的点云 Sensors &gt; Ground Based Lidar &gt; Show Depth Buffer：显示选中的Ground Based Lidar的深度 Sensors &gt; Ground Based Lidar &gt; Export Depth Buffer：以ASCII文件的形式导出选中的Ground Based Lidar传感器的深度图 Sensors &gt; Camera Sensor &gt; Create：创建影像传感器 Sensors &gt; Camera Sensor &gt; Project uncertainty：输出影像模块不确定的点云，输出不确定的x、y、z、3D信息 Sensors &gt; Camera Sensor &gt; Compute points visibility (with octree)：统计选中影像传感器选中的点云。0=NOT VISIBLE，1=VISIBLE Sensors &gt; View from sensor：更改当前的 3D 视图影像设置以匹配选定的传感器的设置 （用泡沫视图模式） Sensors &gt; Compute ranges：计算全部点（对于任何点云）相对于指定传感器的范围 Sensors &gt; Compute scattering angles：计算全部点（对于任何有法线的云）相对于选中传感器分散的角度 Scalar fields &gt; Show histogram：对当前选中的实体显示有效标量域的柱形图 Scalar fields &gt; Compute statistical parameters：计算统计分布（高斯分布、威布尔分布） Scalar fields &gt; Gradient：计算标量域的梯度 Scalar fields &gt; Gaussian filter：通过应用一个立体高斯滤镜，平滑一个标量域 Scalar fields &gt; Bilateral filter：用双边滤镜平滑一个标量域 Scalar fields &gt; Filter by Value：用标量值筛选选定的云 Scalar fields &gt; Convert to RGB：将有效的标量场转化为RGB颜色域 Scalar fields &gt; Convert to random RGB：将有效的标量场转化为随机的RGB颜色域 Scalar fields &gt; Rename：对选中实体重命名有效的标量域 Scalar fields &gt; Add constant SF：用一个常数添加一个标量域 Scalar fields &gt; Add point indexes as SF：用点索引的方式为所选点云创建一个新的标量域 Scalar fields &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Scalar fields &gt; Set SF as coordinate(s)：为选中的点云设置标量域的坐标 Scalar fields &gt; Arithmetic：可以对在同一个点云的两个标量域进行标准运算（+，-，*，/），或者对单个标量域进行函数运算 Scalar fields &gt; Color Scales Manager：色阶管理，可以管理和创建新色域 Scalar fields &gt; Delete：对选中的实体删除有效的标量域 Scalar fields &gt; Delete all (!)：对选中的实体删除全部的有效标量域 Tools： Level：可以选择三个点确定一个平面来操作 Point picking：可以选择一个、两个、三个点来得到各种信息，如点的坐标、RGB、标量值、距离、角度等信息（尤其是两点间的距离） Point list picking：可以选择多个点创建一个点列表，可以输出为一个文件、一个新点云、一个折线 Clean &gt; Noise filter：类似于qPCL插件的S.O.R.滤镜，但又更多功能 Projection &gt; Unroll：展开圆柱或圆锥体的点云成一个平面 Projection &gt; Rasterize：栅格化点云（转化为2.5D网格），然后可以导出为一个新点云或者一个光栅图像 Projection &gt; Contour plot to mesh：可以把一组折线转化为网格，输出边缘轮廓线 Projection &gt; Export coordinate(s) to SF(s)：导出坐标到标量域 Registration &gt; Match bounding-box centers：调整所有选中的实体，让它们的中心在一个地方 Registration &gt; Match scales：匹配所有选中实体的规模 Registration &gt; Align (point pairs picking)：在两个实体中挑选至少三个对应的点来对齐两个实体 Registration &gt; Fine registration (ICP)：自动精确地融合两个实体。前提是：①两个云大体上相融；②表现为同样的对象或者至少有同样的形状 Distances &gt; Cloud/Cloud dist. (cloud-to-cloud distance)：计算两个点云之间的距离 Distances &gt; Cloud/Mesh dist. (cloud-to-mesh distance)：计算点云和网格之间的距离 Distances &gt; Closest Point Set：计算两个点云之间最近的点的集合 Statistics &gt; Local Statistical Test：可以以标量域的局部统计为基础进行分割和过滤点云 Statistics &gt; Compute Stat. Params：计算统计分布（高斯分布、威布尔分布） Segmentation &gt; Label Connected Components：设置最小距离，把所选的云分割成更小的部分，每一部分相互连接 Segmentation &gt; Cross Section：用户可以定义一个裁剪框，可调整框的范围和方向，来裁剪点云。可以用来：①在一个或多个维度重复分割过程；②获取多边形的轮廓 Segmentation &gt; Extract Sections：可以在一个点云的顶部画或者导入多边形来提取截面和轮廓 Fit &gt; Plane：匹配点云中的一个平面和输出各种信息，如拟合 RMS、 垂直平面、地质的倾角、倾角方向值等 Fit &gt; Sphere：适配点云中的一个球体 Fit &gt; 2D Polygon：适配点云中的二维多边形 Fit &gt; Quadric：适配点云中的2.5D曲面 Other &gt; Density：估量一个点云的密度 Other &gt; Curvature：估量一个点云的曲率 Other &gt; Roughness：估量一个点云的粗糙程度 Other &gt; Remove duplicate points：通过设置两点之间最小距离来删除重复的点 Display： Full screen：全屏 Refresh：刷新，强制刷新有效的3D视图的内容（OpenGL图形重绘） Toggle Centered Perspective：在正交视图和对象中心视图模式中切换 Toggle Viewer Based Perspective：在正交视图和透视图中切换 Lock rotation about vert. axis：锁定围绕Z轴的影像旋转 Enter bubble-view mode：进入泡沫视图模式 Render to File：可以渲染当前的3D视图成一个图像文件（支持多数标准文件格式），还可以缩放以适应更大分辨率的屏幕 Display settings：对各种显示进行设置：颜色和材质、色阶、标签、其他 Camera settings：影像设置 Save viewport as object：保存当前3D视图的可视体的参数（影像位置和方、透视状态）为一个可视实体，这个实体自动地添加DB树的根 Adjust zoom：调整缩放比例 Test Frame Rate：测试帧速率，让有效的3D视图在一个较短时间旋转从而估量平均帧数，结果在控制台显示 Lights &gt; Toggle Sun Light：切换太阳光 Lights &gt; Toggle Custom Light：切换自定义的光 Shaders and Filters &gt; Remove filter：禁用任何活动的着色器或者OpenGL过滤器 Active scalar field &gt; Toggle color scale：为所选活动的实体切换色阶 Active scalar field &gt; Show previous SF：改变当前所选对象的标量域，激活先前的标量域 Active scalar field &gt; Show next SF：改变当前所选对象的标量域，激活下一个的标量域 Console：控制台（显示/隐藏） Toolbars：工具栏，包括主工具栏、标量域、视图、插件、GL滤镜 Reset all GUI elements：退出钱自动存储当前GUI信息（位置和工具栏的可见性等），可以恢复原始配置 Plugins：Standard plugins： qHPR (Hidden Point Removal)：如果点云是闭合曲面，则可以过滤（删除）掉通过当前3D影像不能看到的云 qPCL (Point Cloud Library Wrapper)：有PCL库一些方法的接口，主要包括：①计算法线和曲率②异常点和噪声点的去除③平滑点云（移动最小二乘法） qPCV (ShadeVis / Ambient Occlusion)：计算点云的明亮度，类似于光线来自于对象周围的半球或球体（可以自定义光线距离） qPoissonRecon (Poisson Surface Reconstruction)：Poisson表面重建，用三角网络生成算法构建的简单的表面 qRansacSD (RANSAC Shape Detection)：随机抽样一致形状检测，运用自动形状检测算法的简单接口 qSRA (Surface of Revolution Analysis)：计算一个点云和一个假定旋转平面之间的距离（旋转平面用2D轮廓定义），距离计算好后，用户可以创建一个偏差的2D图或者圆柱或圆锥的投影 qCANUPO (Point Cloud Classification)：可自动对点云进行分类，也可以手动分类 qM3C2 (Robust C2C Distances Computation)：用独特的方法计算两个点云之间的有向（稳健）距离 qCork (Boolean Operations on Meshes)：可以执行网格中的布尔操作（也称CSG = 构造实体几何），它基于Cork库 qAnimation：动画渲染插件 qFacets：可以从点云中自动提取二维切面，以它们的垂直距离分开 qCSF (Cloth Simulation Filter)：基于布模拟滤波算法，能实现地面点与非地面点的分离，去除非地面点 qCompass：简单地实现点云中地质结构的它的轨迹的数字化 qBroom (qVirtualBroom)：高效地扫描和清理 qHoughNormals：计算法法线 qGMMREG：对小型实体的非刚性云的匹配 qLAS_FWF：这个插件可以读写标准雷达文件，可以在命令模式下打开LAS 1.3+文件 qPoissonRecon：可以让输入的点云颜色映射到成网格（快速直接地分配到颜色接近输入点颜色的网格顶点） OpenGL ‘shaders’ plugins： qEDL (Eye Dome Lighting)：实时底纹滤镜，用来在空白的点云或者网格中增强少量特质（除了几何信息外，它不依赖于其他信息） qSSAO (Screen Space Ambient Occlusion)：实时底纹滤镜，与环境相似的遮挡 qBlur：一个简单的模糊处理滤镜，主要用于开发人员的演示 Deprecated qKinect (Point Cloud Acquisition with a Kinect)：可以用Kinect设备获取（有色的）点云 3D Views： New：创建3D视图 Close：关闭3D视图 Close All：关闭所有3D视图 Tile：共享的所有 3D 视图之间的显示空间 Cascade：用串联的方式重新排列所有 3D 视图 Next：激活顺序创建的下一个3D视图 Previous：激活顺序创建的上一个3D视图 Help： Help：帮助文档 About：CloudCompare版本信息 About Plugins：插件信息 Thanks： CloudCompare Documentation CloudCompare Wiki Wikipedia]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Makefile 问题及解决]]></title>
      <url>%2F2017%2F03%2F13%2FMakefileIssue%2F</url>
      <content type="text"><![CDATA[问题一makefile文件的clean出错 解决clean下面的那句命令没有缩进，应该用[Tab]缩进 小结 利用 Google、stackoverflow 等含金量高的问题解决平台 注意语法规范 问题二 解决newhello:hello.o hello_fn.o 中的newhello应该写成hello，应该与hello.c中的名字一样 小结 注意编译运行的文件名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iTerm2 + OhMyZsh + agnoster + Powerline + solarized = 漂亮的Mac终端]]></title>
      <url>%2F2017%2F03%2F11%2FFancyMacTerminal%2F</url>
      <content type="text"><![CDATA[唠叨一下自从装了黑苹果后一直用着 Mac 自带的终端（Terminal），相比 Windows 的终端根本无法同台竞技！毕竟 Mac 是基于 Unix 嘛~ 对开发友好太多了。 就是下面这个家伙了👇 本来没觉得什么，直到我看到它👇 颜值碾压，有木有！ 所以就着手折腾了…… iTerm2iTerm是一个非常好的终端模拟器，官网地址：http://iterm2.com/，需要下载它。 zshzsh 是一款强大的虚拟终端，是 Oh My Zsh 的爸爸，所以需要先装它。 在命令行输入： zsh --version 如果输入zsh的当前版本号就说明装好了，一般Mac自带有的 如果没装则需要输入： brew install zsh zsh-completions 这是用Homebrew装，需要Mac上有Homebrew，它的网站：https://brew.sh/ Oh My ZshOh My Zsh 是基于 zsh 的一个扩展工具集，它提供了丰富的扩展功能 它可以通过curl或者wget来安装 via curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; via wget sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 装好之后就可以换到 agnoster 主题，就是之前看到的那张颜值主题，Oh My Zsh 一般自带有这个主题。 可以看看它的默认主题： ls ~/.oh-my-zsh/themes 需要修改主题只需： vim ~/.zshrc 然后把里面 ZSH_THEME 的值改为 ZSH_THEME=&quot;agnoster&quot;，保存退出 （点击这里还有各种主题，任君翻牌~） 应用配置： chsh -s /bin/zsh 重启 iTerm2 然后你会惊喜地发现…… 和颜值主题并不一样！ 难道官方坑爹？ 震惊！oh-my-zsh 竟然做出这种事！ 嘛~ 原来少了 Powerline 的字符集 PowerlineGit 下来安装： git clone git@github.com:powerline/fonts.git cd fonts ./install.sh 然后到 iterm2 配置，设置字体为Roboto Mono for Powerline： 这样就可以有颜值图的效果了~ 然而终端下的 vim 编辑器还是一种颜色~ 作为一个追求完美的 geek 怎能容许此等瑕疵呢！ 所以就继续捣鼓 solarized 配色。 solarizedSolarized 是个很牛逼的配色项目，主流OS、IDE、Editor都有它影子。 # git下Solarized 的源码 git clone git://github.com/altercation/solarized.git # 进入文件夹 cd solarized/vim-colors-solarized/colors #下面可能要管理员权限 sudo mkdir -p ~/.vim/colors sudo cp solarized.vim ~/.vim/colors/ # 创建.vimrc文件 sudo vim ~/.vimrc # 把下面这三行复制进去 syntax enable set background=dark colorscheme solarized 然后保存 .vimrc, 退出 之后打开用 vim 打开文件就是这种效果了： Thanks iTerm2 robbyrussell/oh-my-zsh powerline/fonts altercation/solarized]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 简易入门教程]]></title>
      <url>%2F2017%2F01%2F25%2FMarkdownTutorial%2F</url>
      <content type="text"><![CDATA[自己整理的 Markdown 简介、编辑器推荐、语法、特征等，是 Markdown 的简易入门教程 目录 概述 简介 官方文档 Markdown编辑器 初级语法 标题 粗体和斜体 段落和换行 分隔线 引言 列表 无序列表 有序列表 代码 行内代码块 段落代码块 链接 网址链接 图片链接 指定图片宽高 用图床获取外链 进阶语法 标签 目录 表格 脚注 公式 流程图 序列图 其他 兼容HTML 特殊字符自动转换 反斜杠 自动链接 感谢 概述 简介 Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等。 官方文档 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown编辑器 在线编辑器 dillinger——漂亮强大，支持md, html, pdf 文件导出。 简书——非常漂亮的博客平台，可以自动备份，直接拖入图片。 Windows MarkdownPad——一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 MarkPad——开源软件，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。 Cmd Markdown——作业部落出品，全平台并支持Web端 Mac Mou——简洁优雅，免费又好用，中文兼容性好。 Typora——极致简洁，自定义皮肤。 MacDown——简洁优雅，开源免费。 Ulysses——文字写作推荐。 多平台 Atom——github出的编辑器，支持各种编程语言，可装Markdown插件。 sublimetext——专业编辑器，支持各种编程语言。 初级语法 标题 Markdown 支持两种标题的语法，类 Atx 和类 Setext 形式。 Atx（注意#后面有个空格） # 一级标题 ## 二级标题 ### 三级标题 Setext（-与=数目任意，最好三个及以上，比较直观） 一级标题 ====== 二级标题 ------ 粗体和斜体 粗体 **这是粗体** __这是粗体__ 斜体 *这是斜体* _这是斜体_ 段落和换行 第一种写法（上图的这是第一段），直接敲两个回车键即可 这是第一段 这是第二段 第二种写法（上图的这是第二段），在写完一段后敲两个空格，然后回车写下一段 这是第二段 这是第三段 第三种写法（上图的这是第三段），在写完一段后用HTML的语法：&lt;br /&gt;作为换行，然后写下一段 这是第三段&lt;br /&gt;这是第四段 这是第三段&lt;br /&gt; 这是第四段 分隔线 可以在一行中用三个及以上的星号、减号、等于号、底线来建立分隔线，行内不能有除空格外的其他东西，注意莫被打脸。 (≖ ‿ ≖)✧ *** --- === ___ 引言 &gt; 我想只用一个 “&gt;” 号来写一个多行的引用，所以在扯鸡巴蛋地码字占空间，好像差不多了吧，嗯嗯~ --- &gt; 还有一种写法就是每一行都用一个 “&gt;” 号 &gt; 这样写比较美观一点 --- &gt; &gt; 另外一种就是嵌套引用，就像我一样，用两个“&gt;” 列表 无序列表 无序列表可以在每行开头用星号、加号、减号来表示，也可以三者混合一起，推荐使用相同的字符，避免混乱。 * 一朵百合花 * 两朵百合花 * 三朵百合花 有序列表 有序列表用数字接着一个英文句点来表示，数字可无序，但还是推荐使用1.、2.，避免混乱。 1. 一朵百合花 2. 两朵百合花 3. 三朵百合花 代码 行内代码块 I am a `code` I am a `` ` `` 段落代码块 #### 第一种 int main() { printf(&quot;我是个段落代码块&quot;); return 0; } 另外，可以用三个反引号和语言名，作为标记代码所使用的语言 我的 Mou 编辑器不能识别 (ノ▼Д▼)ノ 链接 网址链接 网址链接有两种形式：行内式、参考式。 不管是哪一种，链接文字都是用 [方括号] 来标记，双引号&quot;&quot;的title可写可不写。 行内式 [huihut](https://huihut.github.io/) [huihut](https://huihut.github.io/ &quot;huihut&quot;) [huihut](https://huihut.github.io/ &apos;huihut&apos;) 参考式 一般写法 [huihut][1] [1]: https://huihut.github.io/ 隐式链接标记——可省略id，只需要[text]与下面[方括号]内容相同即可 [Google][] [Google]: http://google.com/ 拓展 这里的链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [text][a] [text][A] 链接 title 可以用双引号、单引号、圆括号包起来，因此，下面这三种链接的定义都是相同： [1]: https://huihut.github.io/ &quot;title&quot; [1]: https://huihut.github.io/ &apos;title&apos; [1]: https://huihut.github.io/ (title) 特别注意：Markdown.pl 1.0.1 会忽略单引号包起来的链接 title 图片链接 图片链接与上面的网址链接类似，同样有两种形式：行内式和参考式，只不过图片链接在前面加上一个感叹号!，在此不做累述。 行内式 ![huihut](http://ojlsgreog.bkt.clouddn.com/H_ya.png) 参考式 ![谷歌][1] [1]: https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png &quot;Google&quot; 指定图片宽高 Markdown 一般不支持指定图片的宽高，若要指定宽高可以使用普通的 &lt;img&gt; 标签 &lt;img src=&quot;./xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; 如果需要居中可以在外围包围div标签 &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;xxx.png&quot; width = &quot;100&quot; height = &quot;100&quot; alt=&quot;title&quot; align=center /&gt; &lt;/div&gt; 使用支持指定图片大小的 Markdown 编辑器，如 Mou ![](xxx.png =100x100) 用图床获取外链 网上有许多图床，这里推荐两个 七牛图床 和 极简图床。 七牛图床 极简图床 进阶语法 标签 方法一 title: Markdown 简易入门教程 date: 2017-01-25 1:45:50 tags: Markdown categories: 技术 方法三 tags: - Markdown - 语言 categories: - 技术 方法三 tags: [Markdown,语言] categories: [技术] 目录 方法一 这种目录其实是用 HTML 加 Markdown的链接 实现，分为两个部分，目录部分和标题部分。 目录部分——实质是链接，链接的[地址]填需要跳转到的标题的id属性（自定义）。 [跳到标题一](#title1) 标题部分——实质是HTML的标题标签，标签里面的id属性等于待跳转的目录的[地址]。 &lt;h1 id=&quot;title1&quot;&gt;标题一&lt;/h1&gt; 方法二 这种方法非常简单，就是直接添加 [TOC]，标题1~6样式的内容会被提取出来作为目录，然而有些编辑器不能使用这功能，如 Mou 不能使用。我是在有道云笔记的 Markdown 中截图的。 [TOC] # 标题一 …… ## 标题二 …… ### 标题三 这里有个jQuery插件，貌似可以让Markdown生成目录： https://github.com/i5ting/i5ting_ztree_toc 表格 表格一般这样子写，这应该是最简单的写法了 id | name | score --- | --- | --- 001 | Mark | 90 002 | Ford | 80 003 | Alan | 95 还有就是对齐了，用:对齐，:写在在---的左边就是左对齐，右边就是右对齐，两边都写就是居中。 |long_long_id|long_long_name|long_long_score| | --- | :---: | ---: | | 001 | Mark | 90 | | 002 | Ford | 80 | | 003 | Alan | 95 | 脚注 这是脚注一[^1] [^1]: 脚注一 公式 方法一：使用Google Chart &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法二：使用forkosh &lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 方法三：使用codecogs &lt;a href=&quot;https://www.codecogs.com/eqnedit.php?latex=x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://latex.codecogs.com/gif.latex?x=\frac{-b\pm&amp;space;\sqrt{b^{2}-4ac}}{2a}&quot; title=&quot;x=\frac{-b\pm \sqrt{b^{2}-4ac}}{2a}&quot; /&gt;&lt;/a&gt; 方法四：使用MathJax引擎——先加载脚本&lt;script&gt;，后解析公式。 &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; $$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$ 流程图 像流程图这种复杂的功能不推荐在 Markdown 中使用，因为很多编辑器都不支持，我使用了几个编辑器都不能生成流程图，所以上图是在为知笔记官方 Markdown 新手指南中找到的。 123456789st=&gt;start: Starte=&gt;end: Endop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1 更多关于流程图的语法说明： https://github.com/adrai/flowchart.js 序列图 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 更多关于时序图的语法说明： https://github.com/bramp/js-sequence-diagrams 其他语法 兼容HTML Markdown 可以和 HTML 混编，甚至可以完全用 HTML 语法来写。要注意在 HTML 标签中的 Markdown 代码是不起作用的。 &lt;font color=&apos;blue&apos; style=&apos;font-size:30px&apos;&gt;蓝色&lt;/font&gt; &lt;div&gt; # HTML 标签里面的 Markdown 语法不起作用 **你看我没有变粗** &lt;/div&gt; 特殊字符自动转换 HTML 语法——在 HTML 中所有&lt;和&amp;都要转换，包括链接（URL） 用 &amp;lt; 表示 &lt;——起始标签 用 &amp;amp; 表示 &amp; ——标记 HTML 实体 Markdown 语法——Markdown 则会自动转换 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号。如： *literal asterisks* 可用 \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 自动链接 网址自动链接 &lt;https://huihut.github.io/&gt; 电子邮件自动链接 &lt;huihut@outlook.com&gt; 感谢 Markdown: Syntax Markdown 语法说明 (简体中文版) Markdown——入门指南 Markdown语法手册 好用的Markdown编辑器一览 markdown中插入图片怎么定义图片的大小或比例？ Markdown进阶语法整理 为知笔记 Markdown 新手指南 Markdown中插入数学公式的方法 i5ting/i5ting_ztree_toc flowchart.js adrai/flowchart.js js-sequence-diagrams bramp/js-sequence-diagrams]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyCharm自动安装pymysql包失败]]></title>
      <url>%2F2017%2F01%2F21%2FPyCharmInstallPymysqlFail%2F</url>
      <content type="text"><![CDATA[问题描述：在PyCharm中新建Web2Py项目后提示没有pymysql，自动安装失败，如图： 解决方案：1. 安装pip在终端输入 pip -V 如果显示版本路径，就说明pip已经安装了如果没有安装pip则需要在终端安装 ①使用脚本安装pip： 各平台（管理员运行）： python get-pip.py ②使用包管理器安装pip： Mac： sudo easy_install pip Debian &amp; Ubuntu: sudo apt-get install python-pip Fedora: sudo yum install python-pip 2. 安装pymysqlpip install pymysql 3. 正常情况下以上两步就行了。然而我的项目中依然提示没有pymysql，结果发现只是Python版本选错了(ノ▼Д▼)ノ我pymysql是安装到Python2.7，而PyCharm项目是用Python2.6所以就到Preferences &gt; Project Interpreter中调成Python2.7就行了， Thanks http://stackoverflow.com/questions/36956124/permision-issues-while-using-and-installing-python-packages]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搬瓦工Shadowsocks安装及配置多用户(服务端)]]></title>
      <url>%2F2016%2F12%2F03%2FBandwagonShadowsocksServer%2F</url>
      <content type="text"><![CDATA[安装Shadowsocks服务方案一： 搬瓦工VPS为我们准备了Shadowsocks的一键安装，直接在控制面板中有，非常方便。 只需在左边最下面选择Shadowsocks Server 然后选择Install Shadowsocks Server 等待安装完成后选择Go Back 现在可以看到加密协议默认aes-256-cfb,端口默认443 ,密码随机 如果是自己用，到这里就可以使用了，直接在客户端填好这些配置信息就好了。 方案二： 如果不在控制面板上安装或者是在其他没有一键安装的VPS上，可以使用命令安装。 Debian/Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks 优化Shadowsocks性能 在终端通过ssh连上vps（Windows可以用putty连，Mac直接在终端就可以了） 在终端输入vi /etc/sysctl.d/local.conf创建配置文件 按i插入 插入以下内容 # max open files fs.file-max = 1024000 # max read buffer net.core.rmem_max = 67108864 # max write buffer net.core.wmem_max = 67108864 # default read buffer net.core.rmem_default = 65536 # default write buffer net.core.wmem_default = 65536 # max processor input queue net.core.netdev_max_backlog = 4096 # max backlog net.core.somaxconn = 4096 # resist SYN flood attacks net.ipv4.tcp_syncookies = 1 # reuse timewait sockets when safe net.ipv4.tcp_tw_reuse = 1 # turn off fast timewait sockets recycling net.ipv4.tcp_tw_recycle = 0 # short FIN timeout net.ipv4.tcp_fin_timeout = 30 # short keepalive time net.ipv4.tcp_keepalive_time = 1200 # outbound port range net.ipv4.ip_local_port_range = 10000 65000 # max SYN backlog net.ipv4.tcp_max_syn_backlog = 4096 # max timewait sockets held by system simultaneously net.ipv4.tcp_max_tw_buckets = 5000 # TCP receive buffer net.ipv4.tcp_rmem = 4096 87380 67108864 # TCP write buffer net.ipv4.tcp_wmem = 4096 65536 67108864 # turn on path MTU discovery net.ipv4.tcp_mtu_probing = 1 # for high-latency network net.ipv4.tcp_congestion_control = hybla # forward ivp4 net.ipv4.ip_forward = 1 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 配置生效：sysctl --system 配置多用户如果想多用户使用的话就需要更改配置。 首先通过ssh连上vps 在终端输入vi /etc/shadowsocks.json创建配置文件 按i插入 插入以下内容（用户数任意，注意最后一个用户密码后面没有逗号） { &quot;server&quot;:&quot;my_server_ip&quot;, #填入你的IP地址 &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: { &quot;8381&quot;: &quot;foobar1&quot;, #端口号，密码 &quot;8382&quot;: &quot;foobar2&quot;, &quot;8383&quot;: &quot;foobar3&quot;, &quot;8384&quot;: &quot;foobar4&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } Explanation of the fields(配置说明): Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux 然后按Esc退出编辑，按shift+:，输入wq，回车，就保存退出了。 现在就可以启动了，有两种方式启动，前端和后端。前端启动：ssserver -c /etc/shadowsocks.json；后端启动：ssserver -c /etc/shadowsocks.json -d start；停止：ssserver -c /etc/shadowsocks.json -d stop；重启(修改配置要重启才生效)：ssserver -c /etc/shadowsocks.json -d restart 设置开机启动在终端输入vi /etc/rc.local，把里面最后的带有ssserver的一大段默认的代码删除掉，再把ssserver -c /etc/shadowsocks.json -d start加进去，按wq保存退出。 到此就配置好了，试试多用户运行吧！]]></content>
    </entry>

    
  
  
</search>
