<!doctype html>




<html class="theme-next muse" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />





  <link rel="alternate" href="/atom.xml" title="HuiHut" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.0" />






<meta name="description" content="常成员函数声明：&amp;lt;类型标志符&amp;gt;函数名（参数表）const；
class A
{
private:
    const int a;    //常对象成员

public:
    int getValue() const;   //常成员函数
    int getValue();     //普通成员函数
};

int main()
{
    const A a();">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Notes">
<meta property="og:url" content="https://blog.huihut.com/2016/11/20/CppNotes/index.html">
<meta property="og:site_name" content="HuiHut">
<meta property="og:description" content="常成员函数声明：&amp;lt;类型标志符&amp;gt;函数名（参数表）const；
class A
{
private:
    const int a;    //常对象成员

public:
    int getValue() const;   //常成员函数
    int getValue();     //普通成员函数
};

int main()
{
    const A a();">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png">
<meta property="og:updated_time" content="2017-03-25T07:12:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Notes">
<meta name="twitter:description" content="常成员函数声明：&amp;lt;类型标志符&amp;gt;函数名（参数表）const；
class A
{
private:
    const int a;    //常对象成员

public:
    int getValue() const;   //常成员函数
    int getValue();     //普通成员函数
};

int main()
{
    const A a();">
<meta name="twitter:image" content="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: 'huihut',
      author: 'huihut'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.huihut.com/2016/11/20/CppNotes/"/>





  <title> C++ Notes | HuiHut </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96169060-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c6aed63af966e244a9d556ee0bb87fa2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuiHut</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Menghui's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.huihut.com/2016/11/20/CppNotes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Menghui Xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ojlsgreog.bkt.clouddn.com/H_white.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuiHut">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++ Notes
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-20T10:54:13+08:00">
                2016-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2016/11/20/CppNotes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p><strong>声明：&lt;类型标志符&gt;函数名（参数表）const；</strong></p>
<pre><code>class A
{
private:
    const int a;    //常对象成员

public:
    int getValue() const;   //常成员函数
    int getValue();     //普通成员函数
};

int main()
{
    const A a();        //常对象
    canst A *p = &amp;a;    //常指针
    canst A &amp;q = a;     //常引用
}   
</code></pre><p><strong>说明</strong>：</p>
<ol>
<li><strong>常对象只能调用常成员函数</strong>，不能更新类的成员变量，也不能调用该类中没有用const修饰的成员函数。</li>
<li><strong>普通对象可以调用全部成员函数</strong>。</li>
<li>const关键字可以用于对<strong>重载函数</strong>的区分。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，由<strong>隐含使用this指针</strong>。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 </li>
<li>在C++中，this指针被隐含地声明为: X <em> const this,这意味着 <em>*不能给this 指针赋值</em></em>。</li>
<li>由于this并不是一个常规变量，所以，<strong>不能取得this的地址</strong>。</li>
</ol>
<a id="more"></a>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><p>赋值前面定义的变量之前必须要先赋值后面定义的变量</p>
<pre><code>void fun(int a, int b, int c);  //没有赋值

void fun(int a, int b, int c = 30); //可以 
void fun(int a, int b = 20, int c = 30);    //可以
void fun(int a = 10, int b = 20, int c = 30);  //可以

void fun(int a = 10, int b, int c);    //不可以
void fun(int a = 10, int b, int c = 30);    //不可以
</code></pre><p>一般函数声明赋默认值，函数定义不赋值</p>
<pre><code>void fun(int a = 10, int b = 20, int c = 30);  //声明
void fun(int a, int b, int c)
{
    std::cout &lt;&lt; a+b+c &lt;&lt; std::endl;
}   
</code></pre><p>函数实现时赋值，只覆盖前面的值</p>
<pre><code>void fun(int a = 10, int b = 20, int c = 30);  //声明

int main()
{
    fun();              //a=10 b=20 c=30 
    fun(100);           //a=100 b=20 c=30
    fun(100,200);       //a=100 b=200 c=30
    fun(100,200,300);   //a=100 b=200 c=300
    return 0;
}

void fun(int a, int b, int c)
{
    std::cout &lt;&lt; a+b+c &lt;&lt; std::endl;
}
</code></pre><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数和析构函数没有返回值，有返回值是成员函数。</p>
<ul>
<li>复制构造函数</li>
</ul>
<pre><code>class Point
{
public:
    Point(int xx,int yy){X=xx;Y=yy;}
    Point(const Point&amp; p);
    int getX(){returnX;}
    int getY(){returnY;}
private:
    intX,Y;
};
Point::Point(const Point&amp; p)
{
    X=p.X;
    Y=p.Y;
    std::cout&lt;&lt;&quot;拷贝构造函数调用&quot;&lt;&lt;std::endl;
}
int main()
{
    Point p1(1,2);
    Point p2(p1);
    return 0;
}
</code></pre><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数</p>
<ul>
<li><p>相当于把内联函数里面的内容写在调用内联函数处；</p>
</li>
<li><p>相当于不用执行进入函数的步骤，直接执行函数体；</p>
</li>
<li><p>相当于宏，却比宏多了类型检查，真正具有函数特性。</p>
</li>
</ul>
<p>内联函数不能包含循环、递归、switch等复杂操作。</p>
<pre><code>inline void fun(int a)
{
    std::cout&lt;&lt; a &lt;&lt;std::endl;
}
int main()
{
    int x = 1;
    fun(x);     //相当于执行std::cout&lt;&lt; x &lt;&lt;std::endl;
    return 0;
}
</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p>引用必须初始化，初始化后无法再去引用另一个对象</p>
</li>
<li><p>引用后具有该数据类型的所有操作</p>
</li>
</ul>
<pre><code>int main()
{
    int a = 1;
    int &amp;b = a;
    b++;
    std::cout&lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b &lt;&lt;endl;   //a=2, b=2
    return 0;
}
</code></pre><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="new-申请-delete（释放）"><a href="#new-申请-delete（释放）" class="headerlink" title="new(申请) / delete（释放）"></a>new(申请) / delete（释放）</h3><ul>
<li>使用 new 申请内存，使用 delete 释放内存</li>
<li>申请内存需要判断是否成功，释放内存需要设空指针</li>
<li>new 与 delete 配套使用</li>
</ul>
<pre><code>int main()
{
    int *p = new int;       //申请内存
    int *arr = new int[10]; //申请块内存

    //赋值、输出
    *p = 2;
    std::cout &lt;&lt; *p &lt;&lt;std::endl;

    for(int i = 0; i &lt; 10; i++)
    {
        arr[i] = i;
        std::cout &lt;&lt; arr[i] &lt;&lt;std::endl;
    }

    //释放内存
    delete p;   //释放p
    p = NULL;   //置空p

    delete []arr;   //释放arr
    arr = NULL;     //置空arr

    //申请大内存
    int *q = new int[10000]; 

    if(NULL == q)
    {
        std::cout &lt;&lt; &quot;内存分配失败&quot; &lt;&lt;std::endl;
    }
    else
    {
        std::cout &lt;&lt; &quot;内存分配成功&quot; &lt;&lt;std::endl;
    }

    delete []q;     //释放
    q = NULL;       //置空
}
</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>含有纯虚函数的类叫做抽象类。  </p>
<p>只有实现了抽象类全部纯虚函数的子类才可以创建对象。</p>
<h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p>仅含有纯虚函数的抽象类叫做接口类。</p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>用户可以直接访问其成员，并且具有特殊的初始化语法形式。</p>
<p>满足如下特点：</p>
<ul>
<li>所有成员都是public</li>
<li>没有有定于任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有virtual函数</li>
</ul>
<p>如下：</p>
<pre><code>//定义：
struct Date 
{
    int ival;
    string s;
}

//初始化：
Data vall = { 0, &quot;Anna&quot; };
</code></pre><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类</p>
<h3 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h3><ul>
<li>public ： 公共的</li>
<li>protected ： 受保护的</li>
<li>private   :   私有的</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h3><ul>
<li>从栈中实例化  </li>
</ul>
<pre><code>A a;
A a[10];
</code></pre><ul>
<li>从堆中实例化</li>
</ul>
<pre><code>A *p = new A();     //Tips：与 A *p = new A; 一样 
A *q = new A[10];
</code></pre><ul>
<li><strong>Tips：对象指针 = new 类名（&lt;初始值列表&gt;）;</strong><br>当A的构造函数没有参数可以省略括号；<br>当A的构造函数有参数是不能省略括号，而且要填写传入参数。</li>
</ul>
<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><ul>
<li>浅拷贝——只是对象数据的拷贝（指针类型拷贝到的是地址）</li>
<li>深拷贝——对对象本身进行重新构建（指针类型重新开辟内存进行拷贝数据）</li>
</ul>
<h3 id="new-与-malloc-的不同"><a href="#new-与-malloc-的不同" class="headerlink" title="new 与 malloc 的不同"></a>new 与 malloc 的不同</h3><ul>
<li>new 会调用对象的构造函数，malloc不会，仅仅分配内存。</li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><blockquote>
<p><a href="http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html" target="_blank" rel="external">http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html</a></p>
</blockquote>
<ul>
<li><p>初始化类的成员有两种方式，一是<strong>使用初始化列表</strong>，二是<strong>在构造函数体内</strong>进行赋值操作。</p>
</li>
<li><p><strong>初始化列表</strong>是构造函数进行初始化的一种方式，在构造函数后面以冒号开头，后跟一系列以逗号分隔的初始化字段。</p>
</li>
</ul>
<pre><code>class Animal
{
public:
    Animal(int weight,int height):     //A初始化列表
    m_weight(weight),
    m_height(height)
    {
    }
    Animal(int weight,int height)     //B函数体内初始化
    {
        m_weight = weight;
        m_height = height;
    }
private:
    int m_weight;
    int m_height;
}
</code></pre><p><strong>tips：A与B不能同时存在</strong></p>
<h3 id="使用初始化列表的好处："><a href="#使用初始化列表的好处：" class="headerlink" title="使用初始化列表的好处："></a>使用初始化列表的好处：</h3><ul>
<li><p>更高效：少了一次调用默认构造函数的过程。</p>
</li>
<li><p>有些场合必须要用初始化列表：</p>
<blockquote>
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="operator操作符"><a href="#operator操作符" class="headerlink" title="operator操作符"></a>operator操作符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>operator是操作符的意思。它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。</p>
<ul>
<li>运算符重载的本质是函数的重载</li>
</ul>
<h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><h5 id="1-（负号）-的重载"><a href="#1-（负号）-的重载" class="headerlink" title="1.（负号）- 的重载"></a>1.（负号）- 的重载</h5><ul>
<li>友元函数重载</li>
</ul>
<pre><code>class Coordinate
{
friend Coordinate&amp; operator-(Coordinate &amp;coor); //友元函数
public:
    Coordinate(int x, int y);
private:
    int m_ix;
    int m_iy;
}
Coordinate&amp; Coordinate::operator-(Coordinate &amp;coor)
{
    coor.m_ix = -coorm_ix；
    coor.m_iy = -coor.m_iy；
    return *this;
}
int main()
{
    Coordinate coor1(3,4);
    -coor1;     //相当于operator-(coor1);
    return 0;
}
</code></pre><ul>
<li>成员函数重载</li>
</ul>
<pre><code>class Coordinate
{
public:
    Coordinate(int x, int y);
    Coordinate&amp; operator-();    //成员函数
private:
    int m_ix;
    int m_iy;
}
Coordinate&amp; Coordinate::operator-()
{
    m_ix = -m_ix；
    m_iy = -m_iy；
    return *this;
}
int main()
{
    Coordinate coor1(3,4);
    -coor1;     //相当于coor1.operator-();
    return 0;
}
</code></pre><h5 id="2-自增-的重载"><a href="#2-自增-的重载" class="headerlink" title="2. (自增) ++ 的重载"></a>2. (自增) ++ 的重载</h5><ul>
<li>前置 ++ 符号重载（成员函数重载）</li>
</ul>
<pre><code>class Coordinate
{
public:
    Coordinate(int x, int y);
    Coordinate&amp; operator++();    //前置++
private:
    int m_ix;
    int m_iy;
}
Coordinate&amp; Coordinate::operator++()
{
    m_ix++；
    m_iy++；
    return *this;
}
int main()
{
    Coordinate coor1(3,4);
    ++coor1;     //相当于coor1.operator++();
    return 0;
}
</code></pre><ul>
<li>后置 ++ 符号重载（成员函数重载）</li>
</ul>
<pre><code>class Coordinate
{
public:
    Coordinate(int x, int y);
    Coordinate&amp; operator++(int);    //后置++
private:
    int m_ix;
    int m_iy;
}
Coordinate&amp; Coordinate::operator++(int)
{
    Coordinate old(*this);
    m_ix++；
    m_iy++；
    return old;
}
int main()
{
    Coordinate coor1(3,4);
    coor1++;     //相当于coor1.operator++(0);
    return 0;
}
</code></pre><h3 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h3><h5 id="1-（负号）-的重载-1"><a href="#1-（负号）-的重载-1" class="headerlink" title="1.（负号）- 的重载"></a>1.（负号）- 的重载</h5><ul>
<li>友元函数重载</li>
</ul>
<pre><code>class Coordinate
{
friend Coordinate operator+(const Coordinate &amp;c1, const Coordinate &amp;c2);    // 重载+
public:
    Coordinate(int x, int y);
private:
    int m_ix;
    int m_iy;
}
Coordinate operator+(const Coordinate &amp;c1, const Coordinate &amp;c2)
{
    Coordinate temp;
    temp.m_ix = c1.m_ix + c2.m_ix；
    temp.m_iy = c1.m_iy + c2.m_iy；
    return temp;    
}
int main()
{
    Coordinate coor1(3,4);
    Coordinate coor2(5,6);
    Coordinate coor3(0,0);
    coor3 = coor1 + coor2;  //相当于operator+(coor1, coor2); 
    return 0;
}
</code></pre><ul>
<li>成员函数重载</li>
</ul>
<pre><code>class Coordinate
{
public:
    Coordinate(int x, int y);
    Coordinate operator+(const Coordinate &amp;coor);    // 重载+
private:
    int m_ix;
    int m_iy;
}
Coordinate&amp; Coordinate::operator++(const Coordinate &amp;coor)
{
    Coordinate temp;
    temp.m_ix = this-&gt;m_ix + coor.m_ix；
    temp.m_iy = this-&gt;m_iy + coor.m_iy；
    return temp;    
}
int main()
{
    Coordinate coor1(3,4);
    Coordinate coor2(5,6);
    Coordinate coor3(0,0);
    coor3 = coor1 + coor2;  //相当于coor1.operator+(coor2); 
    return 0;
}
</code></pre><h5 id="1-（输出）-lt-lt-的重载-用友元函数重载，-lt-lt-不可以用成员函数重载"><a href="#1-（输出）-lt-lt-的重载-用友元函数重载，-lt-lt-不可以用成员函数重载" class="headerlink" title="1.（输出）&lt;&lt; 的重载 (用友元函数重载，&lt;&lt; 不可以用成员函数重载)"></a>1.（输出）&lt;&lt; 的重载 (用友元函数重载，<strong>&lt;&lt; 不可以用成员函数重载</strong>)</h5><pre><code>class Coordinate
{
friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const Coordinate &amp;coor);    // 重载&lt;&lt;
public:
    Coordinate(int x, int y);
private:
    int m_ix;
    int m_iy;
}
ostream&amp; operator&lt;&lt;(ostream &amp;out, const Coordinate &amp;coor)
{
    out &lt;&lt; coor.m_ix &lt;&lt; &quot;,&quot; &lt;&lt;  coor.m_iy；
    return out;    
}
int main()
{
    Coordinate coor1(3,4);
    cout &lt;&lt; coor;   //相当于operator&lt;&lt;(cout, coor); 
    return 0;
}
</code></pre><h5 id="1-（索引运算符）-的重载-用成员函数重载，-不能用友元函数重载"><a href="#1-（索引运算符）-的重载-用成员函数重载，-不能用友元函数重载" class="headerlink" title="1.（索引运算符）[] 的重载 (用成员函数重载，[]不能用友元函数重载)"></a>1.（索引运算符）[] 的重载 (用成员函数重载，[]不能用友元函数重载)</h5><pre><code>class Coordinate
{
public:
    Coordinate(int x, int y);
    int opetator [](int index);
private:
    int m_ix;
    int m_iy;
}
int Coordinate::operator [](int index)
{
    if(0 == index) return m_ix;
    if(1 == index) return m_iy;
}
int main()
{
    Coordinate coor1(3,4);
    cout &lt;&lt; coor[0];    //相当于coor.operator[](0);
    cout &lt;&lt; coor[1];    //相当于coor.operator[](1);
    return 0;
}
</code></pre><h3 id="功能用法"><a href="#功能用法" class="headerlink" title="功能用法"></a>功能用法</h3><h4 id="1-操作符重载（operator-overloading）"><a href="#1-操作符重载（operator-overloading）" class="headerlink" title="1. 操作符重载（operator overloading）"></a>1. 操作符重载（operator overloading）</h4><blockquote>
<p>格式如下：类型T operator 操作符 ()</p>
</blockquote>
<pre><code>template&lt;typename T&gt; class A
{
public:
    const T operator + (const T&amp; rhs)    //重载 + 号运算符
    {
    return this-&gt;m_ + rhs;
    }
private:
    T m_;
};
</code></pre><h4 id="2-操作隐式转换（operator-casting）"><a href="#2-操作隐式转换（operator-casting）" class="headerlink" title="2. 操作隐式转换（operator casting）"></a>2. 操作隐式转换（operator casting）</h4><blockquote>
<p>格式如下： operator 类型T ()</p>
</blockquote>
<pre><code>class A
{
public:
    operator   B* () { return this-&gt;b_;}
    operator const   B* () {return this-&gt;b_;}
    operator   B&amp; () {return *this-&gt;b_;}
private:
    B* b_;
};

A a;
//当if(a)，编译时，其中它转换成if(a.operator B*())，其实也就是判断 if(a.b_)
</code></pre><h2 id="面向对象特征——封装、继承、多态"><a href="#面向对象特征——封装、继承、多态" class="headerlink" title="面向对象特征——封装、继承、多态"></a>面向对象特征——封装、继承、多态</h2><p><img src="http://img.my.csdn.net/uploads/201211/22/1353564524_6375.png" alt="面向对象特征"></p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li>
<li>关键字：public, protected, friendly, private。不写默认为 friendly。</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>当前类</th>
<th>包内</th>
<th>子孙类</th>
<th>包外 </th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√ </td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>× </td>
</tr>
<tr>
<td>friendly</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>× </td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>× </td>
</tr>
</tbody>
</table>
<pre><code>class A
{
public:
    ...
protected:
    ...
private:
...
}
</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>基类（子类）——&gt; 派生类（父类）</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态，即多种状态，在面向对象语言中，接口的多种不同的实现方式即为多态。多态性在C++中是通过虚函数来实现的。</li>
<li>多态是以封装和继承为基础的。</li>
</ul>
<h3 id="静态多态（早绑定）"><a href="#静态多态（早绑定）" class="headerlink" title="静态多态（早绑定）"></a>静态多态（早绑定）</h3><pre><code>class A
{
public:
    void do(int a);
    void do(int a, int b);
}
</code></pre><h3 id="动态多态（晚绑定）"><a href="#动态多态（晚绑定）" class="headerlink" title="动态多态（晚绑定）"></a>动态多态（晚绑定）</h3><ul>
<li>用 virtual 修饰成员函数，使其成为虚函数</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>普通函数不能是虚函数</li>
<li>静态函数不能是虚函数</li>
<li>内联函数不能是虚函数</li>
<li>构造函数不能是虚函数  </li>
</ul>
<pre><code>class Shape     //形状类
{
public:
    virtual double calcArea()
    {
        ...
    }

}
class Circle : public Shape     //圆形类
{
public:
    virtual double calcArea();
    ...
}
class Rect : public Shape       //矩形类
{
public:
    virtual double calcArea();
    ...
}
int main()
{
    Shape * shape1 = new Circle(4.0);
    Shape * shape2 = new Rect(5.0, 6.0);
    shape1-&gt;calcArea();     //调用圆形类里面的方法
    shape2-&gt;calcArea();     //调用矩形类里面的方法
    return 0；
}
</code></pre><ul>
<li>虚析构函数</li>
</ul>
<pre><code>class Shape
{
public:
    Shape();        //构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();    //虚析构函数
}
class Circle : public Shape     //圆形类
{
public:
    virtual double calcArea();
    ...
}
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1-&gt;calcArea();    
    delete shape1;      //因为是虚析构函数，所以调用子类析构函数后，也调用父类析构函数。
    shape1 = NULL;
    return 0；
}
</code></pre><ul>
<li>纯虚函数 （含有纯虚函数的类叫做抽象类）</li>
</ul>
<pre><code>virtual int A() = 0; 
</code></pre><h2 id="运行时类型识别（RTTI）"><a href="#运行时类型识别（RTTI）" class="headerlink" title="运行时类型识别（RTTI）"></a>运行时类型识别（RTTI）</h2><pre><code>class Flyable                       //【能飞的】
{
public:
    virtual void takeoff() = 0;    //起飞
    virtual void land() = 0;       //降落
}
class Bird : public Flyable         //【鸟】
{
public:
    void foraging() {...}           //觅食
    virtual void takeoff() {...}
    virtual void land() {...}
}
class Plane : public Flyable        //【飞机】
{
public:
    void carry() {...}              //运输
    virtual void take off() {...}
    virtual void land() {...}
}

class type_info
{
public:
    const char* name() const;
    bool operator == (const type_info &amp; rhs) const;
    bool operator != (const type_info &amp; rhs) const;
    int before(const type_info &amp; rhs) const;
    virtual ~type_info();
private:
    ...
}

class doSomething(Flyable *obj)     //【做些事情】
{
    obj-&gt;takeoff();

    cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl;    //输出传入对象类型（Bird or Plane）

    if(typeid(*obj) == typeid(Bird))    //判断对象类型
    {
        Bird *bird = dynamic_cast&lt;Bird *&gt;(obj); //对象转化
        bird-&gt;foraging();
    }

    obj-&gt;land();
}
</code></pre><ul>
<li>dynamic_cast 注意事项：</li>
</ul>
<ol>
<li>只能应用于指针和引用的转化</li>
<li>要转化的类型中必须包含虚函数</li>
<li>转化成功返回子类的地址，转化失败返回NULL</li>
</ol>
<ul>
<li>typeid 注意事项：</li>
</ul>
<ol>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>try{
    ...
}catch(Exception e){
    ...
}

throw ...
</code></pre><h2 id="友元类和友元函数"><a href="#友元类和友元函数" class="headerlink" title="友元类和友元函数"></a>友元类和友元函数</h2><ul>
<li>能访问私有成员  </li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p><strong>预处理器：</strong></p>
<p>预处理器是为了确保头文件多次包含仍能安全工作的常用的技术。</p>
<p><strong>头文件保护符：</strong></p>
<pre><code>#define     //把一个名字设定为预处理变量

//检查某个指定的预处理变量是否已经定义
#ifdef      //当且仅当变量已定义时为真
#ifndef     //当且仅当变量已定义时为真

#endif      //检查结果为真，则执行到endif为止 

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include &lt;string&gt;
struct Sales_data{
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
</code></pre><p><strong>空指针:</strong>  </p>
<p>以往程序使用名为NULL的预处理变量（这个变量在头文件cstdlib中定义，值为0）；  </p>
<p>在C++11新标准中最好使用nullptr，同时尽量避免使用NULL，如：  </p>
<pre><code>int *p = nullptr;
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="C-中的struct和class的区别"><a href="#C-中的struct和class的区别" class="headerlink" title="C++中的struct和class的区别"></a>C++中的struct和class的区别</h3><blockquote>
<p><a href="http://blog.sina.com.cn/s/blog_48f587a80100k630.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_48f587a80100k630.html</a></p>
</blockquote>
<ul>
<li><p>最本质(唯一)的一个区别就是默认的访问控制<br>1）默认的继承访问权限。struct是public的，class是private的。<br>2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</p>
</li>
<li><p>总的来说，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。</p>
</li>
</ul>
<p>C/C++中struct和class的区别：</p>
<blockquote>
<p><a href="http://genwoxuec.blog.51cto.com/1852764/503334" target="_blank" rel="external">http://genwoxuec.blog.51cto.com/1852764/503334</a></p>
</blockquote>
<h3 id="struct和typedef-struct"><a href="#struct和typedef-struct" class="headerlink" title="struct和typedef struct"></a>struct和typedef struct</h3><blockquote>
<p><a href="http://www.cnblogs.com/qyaizs/articles/2039101.html" target="_blank" rel="external">http://www.cnblogs.com/qyaizs/articles/2039101.html</a><br><a href="http://blog.csdn.net/haiou0/article/details/6877718" target="_blank" rel="external">http://blog.csdn.net/haiou0/article/details/6877718</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/03/BandwagonShadowsocksServer/" rel="prev" title="搬瓦工Shadowsocks安装及配置多用户(服务端)">
                搬瓦工Shadowsocks安装及配置多用户(服务端) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ojlsgreog.bkt.clouddn.com/H_white.png"
               alt="Menghui Xie" />
          <p class="site-author-name" itemprop="name">Menghui Xie</p>
           
              <p class="site-description motion-element" itemprop="description">Stay hungry. Stay foolish.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/huihut" target="_blank" title="Github">
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/MenghuiXie" target="_blank" title="Twitter">
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/huihuth" target="_blank" title="Weibo">
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#常成员函数"><span class="nav-number">1.</span> <span class="nav-text">常成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number"></span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数默认值"><span class="nav-number">1.</span> <span class="nav-text">函数默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和析构函数"><span class="nav-number">2.</span> <span class="nav-text">构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内联函数"><span class="nav-number">3.</span> <span class="nav-text">内联函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number"></span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number"></span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-申请-delete（释放）"><span class="nav-number">1.</span> <span class="nav-text">new(申请) / delete（释放）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number"></span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口类"><span class="nav-number">2.</span> <span class="nav-text">接口类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合类"><span class="nav-number">3.</span> <span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字面值常量类"><span class="nav-number">4.</span> <span class="nav-text">字面值常量类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问限定符"><span class="nav-number">5.</span> <span class="nav-text">访问限定符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number"></span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的实例化"><span class="nav-number">1.</span> <span class="nav-text">对象的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的拷贝"><span class="nav-number">2.</span> <span class="nav-text">对象的拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-与-malloc-的不同"><span class="nav-number">3.</span> <span class="nav-text">new 与 malloc 的不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化列表"><span class="nav-number"></span> <span class="nav-text">初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用初始化列表的好处："><span class="nav-number">1.</span> <span class="nav-text">使用初始化列表的好处：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator操作符"><span class="nav-number"></span> <span class="nav-text">operator操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#含义"><span class="nav-number">1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一元运算符重载"><span class="nav-number">2.</span> <span class="nav-text">一元运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-（负号）-的重载"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.（负号）- 的重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-自增-的重载"><span class="nav-number">2.0.2.</span> <span class="nav-text">2. (自增) ++ 的重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二元运算符重载"><span class="nav-number">3.</span> <span class="nav-text">二元运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-（负号）-的重载-1"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.（负号）- 的重载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-（输出）-lt-lt-的重载-用友元函数重载，-lt-lt-不可以用成员函数重载"><span class="nav-number">3.0.2.</span> <span class="nav-text">1.（输出）<< 的重载 (用友元函数重载，<< 不可以用成员函数重载)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-（索引运算符）-的重载-用成员函数重载，-不能用友元函数重载"><span class="nav-number">3.0.3.</span> <span class="nav-text">1.（索引运算符）[] 的重载 (用成员函数重载，[]不能用友元函数重载)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能用法"><span class="nav-number">4.</span> <span class="nav-text">功能用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-操作符重载（operator-overloading）"><span class="nav-number">4.1.</span> <span class="nav-text">1. 操作符重载（operator overloading）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-操作隐式转换（operator-casting）"><span class="nav-number">4.2.</span> <span class="nav-text">2. 操作隐式转换（operator casting）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象特征——封装、继承、多态"><span class="nav-number"></span> <span class="nav-text">面向对象特征——封装、继承、多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number"></span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number"></span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number"></span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态多态（早绑定）"><span class="nav-number">1.</span> <span class="nav-text">静态多态（早绑定）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态多态（晚绑定）"><span class="nav-number">2.</span> <span class="nav-text">动态多态（晚绑定）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时类型识别（RTTI）"><span class="nav-number"></span> <span class="nav-text">运行时类型识别（RTTI）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number"></span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友元类和友元函数"><span class="nav-number"></span> <span class="nav-text">友元类和友元函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理"><span class="nav-number"></span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number"></span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-中的struct和class的区别"><span class="nav-number">1.</span> <span class="nav-text">C++中的struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct和typedef-struct"><span class="nav-number">2.</span> <span class="nav-text">struct和typedef struct</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Menghui Xie</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "ea1e5253dadb4824bb64739659b740a7",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  

  

</body>
</html>
